import { __decorate } from "tslib";
import { customElement, scale, clamp, roundToNearest, stringFormat } from '@here/hds-base';
import '@here/hds-input';
import '@here/hds-label';
import { html, LitElement, nothing } from 'lit';
import { property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styles } from './hds-slider.css.js';
import { styleMap } from 'lit/directives/style-map.js';
import { repeat } from 'lit/directives/repeat.js';
const PROP_CONVERTER = { fromAttribute: value => value?.split(',') };
/**
 *
 * @event {CustomEvent<{value: number, value2?: number}>} change Fired when the value(s) of the slider changes `SliderChangePayload`
 *
 */
let Slider = class Slider extends LitElement {
    constructor() {
        super();
        this.disabled = false;
        this.min = 0;
        this.max = 100;
        this.step = 0;
        this.type = 'default';
        this.size = 'medium';
        this.textStart = '';
        this.textEnd = '';
        this.noTrackFill = false;
        this.trackColors = [];
        this.trackColorsLengths = [];
        this.stepType = 'none';
        this.stepValues = [];
        this.stepLabels = [];
        this.iconStart = '';
        this.iconStartStyle = 'solid';
        this.iconStartCategory = 'core-ui';
        this.iconEnd = '';
        this.iconEndStyle = 'solid';
        this.iconEndCategory = 'core-ui';
        this.value = 0;
        this.value2 = 0;
        this._lastActiveThumb = 1;
        this._thumbDraggingStartX = 0;
        this._onDocumentMouseUp = this._onDocumentMouseUp.bind(this);
        this._onDocumentMouseMove = this._onDocumentMouseMove.bind(this);
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback();
        this.ownerDocument.addEventListener('mousemove', this._onDocumentMouseMove);
        this.ownerDocument.addEventListener('mouseup', this._onDocumentMouseUp);
    }
    disconnectedCallback() {
        this.ownerDocument.removeEventListener('mousemove', this._onDocumentMouseMove);
        this.ownerDocument.removeEventListener('mouseup', this._onDocumentMouseUp);
        super.disconnectedCallback && super.disconnectedCallback();
    }
    updated(_changedProperties) {
        if (this.type === 'default') {
            if (_changedProperties.has('value')) {
                this.value = clamp(roundToNearest(this.value, this.step), this.min, this.max);
                this._updateDom(_changedProperties);
            }
        }
        else if (this.type === 'range') {
            this.value = clamp(roundToNearest(this.value, this.step), this.min, Math.min(this.value2, this.max));
            this.value2 = clamp(roundToNearest(this.value2, this.step), Math.max(this.min, this.value), this.max);
            this._updateDom(_changedProperties);
        }
        const isValueChanged = _changedProperties.has('value') &&
            _changedProperties.get('value') !== this.value &&
            _changedProperties.get('value') !== undefined;
        const isValue2Changed = _changedProperties.has('value2') &&
            _changedProperties.get('value2') !== this.value2 &&
            _changedProperties.get('value2') !== undefined;
        if (isValueChanged || isValue2Changed) {
            const detail = { value: this.value };
            if (this.type === 'range') {
                detail.value2 = this.value2;
            }
            this.dispatchEvent(new CustomEvent('change', {
                detail,
                bubbles: true,
                composed: true,
            }));
        }
    }
    _updateDom(_changedProperties) {
        if (this.type === 'default') {
            this.thumb1Element.style.left = `${scale(this.value, this.min, this.max, 0, 100)}%`;
            this._lastActiveThumb = 1;
        }
        else if (this.type === 'range') {
            this.thumb1Element.style.left = `${scale(this.value, this.min, this.max, 0, 100)}%`;
            this.thumb2Element.style.left = `${scale(this.value2, this.min, this.max, 0, 100)}%`;
            if ((_changedProperties.has('value') && !_changedProperties.has('value2')) ||
                (this.value === this.value2 && this.value === this.max)) {
                this._lastActiveThumb = 1;
            }
            else if ((_changedProperties.has('value2') && !_changedProperties.has('value')) ||
                (this.value === this.value2 && this.value === this.min)) {
                this._lastActiveThumb = 2;
            }
        }
    }
    _onSliderMouseDown(e) {
        if (this.disabled)
            return;
        e.preventDefault();
        if (e.target === this.thumb1Element || e.target === this.thumb2Element) {
            this._thumbInDragging = e.target;
            this._thumbDraggingStartX = e.clientX - e.target.offsetLeft;
        }
        else {
            const sliderWidth = this.sliderElement.offsetWidth;
            const rect = this.sliderElement.getBoundingClientRect();
            const newLeft = e.clientX - rect.left;
            if (this.type === 'default') {
                this.value = scale(newLeft, 0, sliderWidth, this.min, this.max);
            }
            else if (this.type === 'range') {
                const newValue = scale(newLeft, 0, sliderWidth, this.min, this.max);
                if (Math.abs(newValue - this.value) <= Math.abs(newValue - this.value2)) {
                    this.value = newValue;
                }
                else if (Math.abs(newValue - this.value) >= Math.abs(newValue - this.value2)) {
                    this.value2 = newValue;
                }
            }
        }
    }
    _onDocumentMouseMove(e) {
        if (this.disabled)
            return;
        if (!this._thumbInDragging)
            return;
        const isThumb1InDragging = this._thumbInDragging === this.thumb1Element;
        const isThumb2InDragging = this._thumbInDragging === this.thumb2Element;
        const sliderWidth = this.sliderElement.offsetWidth;
        const thumbWidth = this._thumbInDragging.offsetWidth;
        const rightEdge = this.sliderElement.offsetWidth - this._thumbInDragging.offsetWidth + thumbWidth;
        const leftEdge = 0;
        let newLeft = clamp(e.clientX - this._thumbDraggingStartX, leftEdge, rightEdge);
        if (this.type === 'default') {
            this.value = scale(newLeft, 0, sliderWidth, this.min, this.max);
        }
        else if (this.type === 'range') {
            if (isThumb1InDragging) {
                if (newLeft > this.thumb2Element.offsetLeft) {
                    newLeft = this.thumb2Element.offsetLeft;
                }
                this.value = scale(newLeft, 0, sliderWidth, this.min, this.max);
            }
            else if (isThumb2InDragging) {
                if (newLeft < this.thumb1Element.offsetLeft) {
                    newLeft = this.thumb1Element.offsetLeft;
                }
                this.value2 = scale(newLeft, 0, sliderWidth, this.min, this.max);
            }
        }
    }
    _onDocumentMouseUp() {
        if (this._thumbInDragging) {
            this._thumbInDragging = undefined;
        }
    }
    renderThumb1() {
        return html `<button
      @focus="${() => {
            this._lastActiveThumb = 1;
        }}"
      class="thumb thumb1"
    ></button>`;
    }
    renderThumb2() {
        if (this.type === 'default')
            return nothing;
        return html `<button
      @focus="${() => {
            this._lastActiveThumb = 2;
        }}"
      class="thumb thumb2"
    ></button>`;
    }
    onKeyDown(e) {
        if (this.disabled)
            return;
        const step = this.step === 0 ? 1 : this.step;
        if (e.key === 'ArrowLeft') {
            if (this._lastActiveThumb === 1) {
                this.value -= step;
            }
            else if (this._lastActiveThumb === 2) {
                this.value2 -= step;
            }
        }
        else if (e.key === 'ArrowRight') {
            if (this._lastActiveThumb === 1) {
                this.value += step;
            }
            else if (this._lastActiveThumb === 2) {
                this.value2 += step;
            }
        }
    }
    renderStep(value, label) {
        const valueNorm = clamp(value, this.min, this.max);
        const stepMarkClasses = {
            'hds-slider--step': true,
            'hds-slider--step-min': valueNorm === this.min,
            'hds-slider--step-max': valueNorm === this.max,
        };
        const stepMarkStyles = {
            left: `${scale(valueNorm, this.min, this.max, 0, 100)}%`,
        };
        const labelClasses = {
            'hds-slider--label': true,
            'hds-slider--label-min': valueNorm === this.min,
            'hds-slider--label-max': valueNorm === this.max,
        };
        return html ` <div class="${classMap(stepMarkClasses)}" style="${styleMap(stepMarkStyles)}">
      <div class="${classMap(labelClasses)}">${label}</div>
    </div>`;
    }
    renderAllSteps() {
        if (this.step === 0)
            return nothing;
        if (this.stepType === 'none')
            return nothing;
        let valuesArray = [];
        const valuesToLabels = Object.fromEntries(this.stepValues.map((value, index) => [value, this.stepLabels[index]]));
        if (this.stepValues.length === 0) {
            const numOfSteps = Math.abs(this.max - this.min) / this.step;
            const numOfStepsArray = Array.from({ length: numOfSteps + 1 });
            valuesArray = numOfStepsArray.map((_, index) => {
                const valueAtStep = index * this.step;
                return valueAtStep;
            });
        }
        else {
            valuesArray = this.stepValues;
        }
        return html `<div class="hds-slider--steps">
      ${repeat(valuesArray, value => this.renderStep(value, valuesToLabels[value]))}
    </div>`;
    }
    formatTemplateString(str) {
        return stringFormat(str, {
            value: this.value,
            value2: this.value2,
            min: this.min,
            max: this.max,
            step: this.step,
        });
    }
    renderTextStart() {
        if (this.textStart.length === 0)
            return nothing;
        return html ` <div class="text-start">${this.formatTemplateString(this.textStart)}</div> `;
    }
    renderTextEnd() {
        if (!this.textEnd)
            return nothing;
        return html ` <div class="text-end">${this.formatTemplateString(this.textEnd)}</div> `;
    }
    renderIconStart() {
        if (!this.iconStart)
            return nothing;
        return html `<hds-icon
      class="icon-start"
      name="${this.iconStart}"
      size="24px"
      category="${this.iconStartCategory}"
      icon-style="${this.iconStartStyle}"
    ></hds-icon> `;
    }
    renderIconEnd() {
        if (!this.iconEnd)
            return nothing;
        return html `<hds-icon
      class="icon-end"
      name="${this.iconEnd}"
      size="24px"
      category="${this.iconEndCategory}"
      icon-style="${this.iconEndStyle}"
    ></hds-icon> `;
    }
    render() {
        const sliderClasses = {
            '-hds-slider-wrapper': true,
            [`${this.disabled ? 'disabled' : 'not-disabled'}`]: true,
            [`last-active-thumb${this._lastActiveThumb}`]: true,
            [`hds-slider--size-${this.size}`]: true,
            [`track-fill-color-${this.noTrackFill ? 'off' : 'on'}`]: true,
            [`hds-slider--step-type-${this.stepType}`]: true,
        };
        const labelsWordsMax = this.stepLabels.length === 0
            ? 0
            : this.stepLabels.map(w => w.split(' ').length).reduce((a, b) => (a > b ? a : b));
        const sliderStyles = {
            '--hds-slider--label-max-n-words': `${labelsWordsMax}`,
        };
        if (this.trackColors.length > 0) {
            const trackColorsLengths = this.trackColorsLengths.length === this.trackColors.length
                ? this.trackColorsLengths
                : this.trackColors.map((_, idx) => `${(100.0 / this.trackColors.length) * (idx + 1)}%`);
            const gradientColorSteps = this.trackColors
                .map((c, idx) => `${c} 0 ${trackColorsLengths[idx]}`)
                .join(',');
            sliderStyles['--hds-slider--track-background'] = `linear-gradient(to right, ${gradientColorSteps})`;
        }
        if (this.type === 'default') {
            if (this.trackFillStart !== undefined) {
                sliderStyles['--hds-slider--track-fill-start'] = `${scale(Math.min(this.value, this.trackFillStart), this.min, this.max, 0, 100)}%`;
                sliderStyles['--hds-slider--track-fill-end'] = `${100.0 - scale(Math.max(this.value, this.trackFillStart), this.min, this.max, 0, 100)}%`;
            }
            else {
                sliderStyles['--hds-slider--track-fill-start'] = '0%';
                sliderStyles['--hds-slider--track-fill-end'] = `${100.0 - scale(this.value, this.min, this.max, 0, 100)}%`;
            }
        }
        else if (this.type === 'range') {
            sliderStyles['--hds-slider--track-fill-start'] = `${scale(this.value, this.min, this.max, 0, 100)}%`;
            sliderStyles['--hds-slider--track-fill-end'] = `${100.0 - scale(this.value2, this.min, this.max, 0, 100)}%`;
        }
        return html `
      <div
        class="${classMap(sliderClasses)}"
        style="${styleMap(sliderStyles)}"
        @keydown="${this.onKeyDown}"
      >
        ${this.renderIconStart()} ${this.renderTextStart()}
        <div class="slider" @mousedown="${this._onSliderMouseDown}">
          <div class="track">
            <div class="track-fill"></div>
          </div>
          ${this.renderAllSteps()} ${this.renderThumb1()} ${this.renderThumb2()}
        </div>
        ${this.renderTextEnd()} ${this.renderIconEnd()}
      </div>
    `;
    }
};
Slider.styles = styles;
Slider.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
__decorate([
    property({ type: Boolean })
], Slider.prototype, "disabled", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "min", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "max", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "step", void 0);
__decorate([
    property({ type: String })
], Slider.prototype, "type", void 0);
__decorate([
    property({ type: String })
], Slider.prototype, "size", void 0);
__decorate([
    property({ type: String, attribute: 'text-start' })
], Slider.prototype, "textStart", void 0);
__decorate([
    property({ type: String, attribute: 'text-end' })
], Slider.prototype, "textEnd", void 0);
__decorate([
    property({ type: Number, attribute: 'track-fill-start' })
], Slider.prototype, "trackFillStart", void 0);
__decorate([
    property({ type: Boolean, attribute: 'no-track-fill' })
], Slider.prototype, "noTrackFill", void 0);
__decorate([
    property({ type: Array, attribute: 'track-colors', converter: PROP_CONVERTER })
], Slider.prototype, "trackColors", void 0);
__decorate([
    property({ type: Array, attribute: 'track-colors-lengths', converter: PROP_CONVERTER })
], Slider.prototype, "trackColorsLengths", void 0);
__decorate([
    property({ type: String, attribute: 'step-type' })
], Slider.prototype, "stepType", void 0);
__decorate([
    property({ type: Array, attribute: 'step-values', converter: PROP_CONVERTER })
], Slider.prototype, "stepValues", void 0);
__decorate([
    property({ type: Array, attribute: 'step-labels', converter: PROP_CONVERTER })
], Slider.prototype, "stepLabels", void 0);
__decorate([
    property({ type: String, attribute: 'icon-start' })
], Slider.prototype, "iconStart", void 0);
__decorate([
    property({ type: String, attribute: 'icon-start-style' })
], Slider.prototype, "iconStartStyle", void 0);
__decorate([
    property({ type: String, attribute: 'icon-start-category' })
], Slider.prototype, "iconStartCategory", void 0);
__decorate([
    property({ type: String, attribute: 'icon-end' })
], Slider.prototype, "iconEnd", void 0);
__decorate([
    property({ type: String, attribute: 'icon-end-style' })
], Slider.prototype, "iconEndStyle", void 0);
__decorate([
    property({ type: String, attribute: 'icon-end-category' })
], Slider.prototype, "iconEndCategory", void 0);
__decorate([
    query('.thumb1')
], Slider.prototype, "thumb1Element", void 0);
__decorate([
    query('.thumb2')
], Slider.prototype, "thumb2Element", void 0);
__decorate([
    query('.slider')
], Slider.prototype, "sliderElement", void 0);
__decorate([
    property({ type: Number, attribute: 'value' })
], Slider.prototype, "value", void 0);
__decorate([
    property({ type: Number, attribute: 'value2' })
], Slider.prototype, "value2", void 0);
__decorate([
    state()
], Slider.prototype, "_lastActiveThumb", void 0);
Slider = __decorate([
    customElement('hds-slider')
], Slider);
export { Slider };
//# sourceMappingURL=hds-slider.js.map