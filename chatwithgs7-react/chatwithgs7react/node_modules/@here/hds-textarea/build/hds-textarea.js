var Textarea_1;
import { __decorate } from "tslib";
import { customElement, BaseElement } from '@here/hds-base';
import '@here/hds-label';
import { html, LitElement, nothing } from 'lit';
import { property, query } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { styles } from './hds-textarea.css.js';
/**
 *
 * @event {CustomEvent<{value: string}>} input Fired when the value of the element has changed `TextareaInputPayload`
 * @event {CustomEvent<{value: string}>} change Fired when an alteration to the element's value is committed by the user `TextChangePayload`
 * @event {CustomEvent<Textarea>} focus Fired when the element has focus
 * @event {CustomEvent<Textarea>} blur Fired when the element loses focus
 * @event {KeyboardEvent} keydown Fired when a key is pressed
 * @event {KeyboardEvent} keyup Fired when a key is released
 *
 */
let Textarea = Textarea_1 = class Textarea extends BaseElement {
    constructor() {
        super(...arguments);
        this.isTabbable = true;
        this.name = '';
        this.rows = -1;
        this.cols = -1;
        this.disabled = false;
        this.readonly = false;
        this.required = false;
        this.autofocus = false;
        this.minlength = -1;
        this.maxlength = -1;
        this.charCounter = false;
        this.error = false;
        this.resize = 'none';
        this.autocomplete = '';
        this._value = '';
    }
    get charCounterVisible() {
        return this.charCounter && this.maxlength !== -1;
    }
    get errorTextVisible() {
        return this.error && !!this.errorText;
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback();
        Textarea_1.idCounter += 1;
        if (this.label) {
            this._labelId = `hds-textarea-label-${Textarea_1.idCounter}`;
        }
    }
    firstUpdated() {
        this.autofocus && this.focus();
    }
    updated(_changedProps) {
        if (_changedProps.has('value') && _changedProps.get('value') !== undefined) {
            this.textareaElement.value = this.value;
            this.dispatchEvent(new CustomEvent('input', {
                detail: { value: this.value },
                bubbles: true,
                composed: true,
            }));
        }
    }
    get value() {
        return this._value;
    }
    set value(val) {
        const oldValue = this._value;
        this._value = val;
        this.requestUpdate('value', oldValue);
    }
    setSelectionRange(start, end, direction) {
        this.textareaElement.setSelectionRange(start, end, direction);
    }
    setRangeText(replacement, start, end, selectionMode) {
        if (start && end) {
            this.textareaElement.setRangeText(replacement, start, end, selectionMode);
        }
        else {
            this.textareaElement.setRangeText(replacement);
        }
        this.value = this.textareaElement.value;
    }
    checkValidity() {
        return this.textareaElement.checkValidity();
    }
    reportValidity() {
        return this.textareaElement.reportValidity();
    }
    select() {
        this.textareaElement.select();
    }
    setCustomValidity(error) {
        this.textareaElement.setCustomValidity(error);
    }
    focus() {
        this.textareaElement.focus();
    }
    blur() {
        this.textareaElement.blur();
    }
    async clear() {
        this.value = '';
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('change', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    async _nativeFocus(e) {
        e.stopPropagation();
        e.preventDefault();
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('focus', {
            detail: this,
            bubbles: true,
            composed: true,
        }));
    }
    async _nativeBlur(e) {
        e.stopPropagation();
        e.preventDefault();
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('blur', {
            detail: this,
            bubbles: true,
            composed: true,
        }));
    }
    renderCharCounter() {
        const length = Math.min(this.value.length, this.maxlength);
        return this.charCounterVisible
            ? html ` <span slot="secondary">${length}/${this.maxlength}</span>`
            : nothing;
    }
    renderSecondaryLabel() {
        return this.secondaryLabel
            ? html ` <span slot="secondary">${this.secondaryLabel}</span>`
            : nothing;
    }
    renderLabels() {
        if (this.label || this.secondaryLabel) {
            return html ` <hds-label>${this.label || nothing} ${this.renderSecondaryLabel()}</hds-label>`;
        }
        return nothing;
    }
    renderHelperText() {
        if (!this.charCounterVisible && !this.errorTextVisible) {
            return undefined;
        }
        return html `
      <hds-label type="assistive" variant="error"
        >${this.errorTextVisible ? this.errorText : nothing} ${this.renderCharCounter()}
      </hds-label>
    `;
    }
    render() {
        const classes = {
            disabled: this.disabled,
            readonly: this.readonly,
            required: this.required,
            error: this.error,
        };
        const localStyles = {
            resize: this.resize,
        };
        return html `
      <div class="wrapper">
        ${this.renderLabels()}
        <textarea
          .value="${this.value}"
          autocomplete="${ifDefined(this.autocomplete || undefined)}"
          id="${ifDefined(this.id === '' ? undefined : this.id)}"
          name="${ifDefined(this.name === '' ? undefined : this.name)}"
          placeholder="${ifDefined(this.placeholder === '' ? undefined : this.placeholder)}"
          ?required="${this.required}"
          ?disabled="${this.disabled}"
          ?readonly="${this.readonly}"
          rows="${ifDefined(this.rows === -1 ? undefined : this.rows)}"
          cols="${ifDefined(this.cols === -1 ? undefined : this.cols)}"
          minlength="${ifDefined(this.minlength === -1 ? undefined : this.minlength)}"
          maxlength="${ifDefined(this.maxlength === -1 ? undefined : this.maxlength)}"
          style=${styleMap(localStyles)}
          class="${classMap(classes)}"
          @change="${this._nativeChange}"
          @input="${this._nativeInput}"
          @focus="${this._nativeFocus}"
          @blur="${this._nativeBlur}"
          @keydown="${this._nativeKeyPress}"
          @keyup="${this._nativeKeyPress}"
          aria-labelledby="${ifDefined(this.getAriaLabelledBy())}"
        >
        </textarea>
        ${this.renderHelperText()}
      </div>
    `;
    }
    getAriaLabelledBy() {
        if (this.label)
            return this._labelId;
        if (this.ariaLabelledBy)
            return this.ariaLabelledBy;
        return undefined;
    }
    async _nativeInput(e) {
        e.stopPropagation();
        e.preventDefault();
        this.value = this.textareaElement.value;
        await this.updateComplete;
    }
    async _nativeChange(e) {
        e.stopPropagation();
        e.preventDefault();
        this.value = this.textareaElement.value;
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('change', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    async _nativeKeyPress(e) {
        e.stopPropagation();
        await this.updateComplete;
        this.dispatchEvent(new KeyboardEvent(e.type, e));
    }
};
Textarea.styles = styles;
Textarea.idCounter = 0;
Textarea.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
Textarea.formAssociated = true;
__decorate([
    property({ type: String })
], Textarea.prototype, "name", void 0);
__decorate([
    property({ type: String })
], Textarea.prototype, "placeholder", void 0);
__decorate([
    property({ type: String })
], Textarea.prototype, "label", void 0);
__decorate([
    property({ type: String, attribute: 'secondary-label' })
], Textarea.prototype, "secondaryLabel", void 0);
__decorate([
    property({ type: Number })
], Textarea.prototype, "rows", void 0);
__decorate([
    property({ type: Number })
], Textarea.prototype, "cols", void 0);
__decorate([
    property({ type: Boolean })
], Textarea.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean })
], Textarea.prototype, "readonly", void 0);
__decorate([
    property({ type: Boolean })
], Textarea.prototype, "required", void 0);
__decorate([
    property({ type: Boolean })
], Textarea.prototype, "autofocus", void 0);
__decorate([
    property({ type: Number })
], Textarea.prototype, "minlength", void 0);
__decorate([
    property({ type: Number })
], Textarea.prototype, "maxlength", void 0);
__decorate([
    property({ type: Boolean, attribute: 'char-counter' })
], Textarea.prototype, "charCounter", void 0);
__decorate([
    property({ type: Boolean })
], Textarea.prototype, "error", void 0);
__decorate([
    property({ type: String, attribute: 'error-text' })
], Textarea.prototype, "errorText", void 0);
__decorate([
    property({ type: String, attribute: 'aria-labelledby' })
], Textarea.prototype, "ariaLabelledBy", void 0);
__decorate([
    property({ type: String, reflect: true, attribute: true })
], Textarea.prototype, "resize", void 0);
__decorate([
    property({ type: String })
], Textarea.prototype, "autocomplete", void 0);
__decorate([
    query('textarea')
], Textarea.prototype, "textareaElement", void 0);
__decorate([
    property({ type: String, reflect: true, attribute: 'value' })
], Textarea.prototype, "value", null);
Textarea = Textarea_1 = __decorate([
    customElement('hds-textarea')
], Textarea);
export { Textarea };
//# sourceMappingURL=hds-textarea.js.map