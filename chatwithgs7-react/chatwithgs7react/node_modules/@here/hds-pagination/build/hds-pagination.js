import { __decorate } from "tslib";
import { customElement, stringFormat } from '@here/hds-base';
import { html, LitElement, nothing } from 'lit';
import { property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styles } from './hds-pagination.css.js';
/**
 * @event {CustomEvent<{page: number, itemsPerPage: number, itemsFrom: number, itemsTo: number}>} change Event fired when page/itemsPerPage changed `PaginationChangePayload`
 */
let Pagination = class Pagination extends LitElement {
    constructor() {
        super(...arguments);
        this.disabled = false;
        this.itemsPerPageValues = [];
        this.pageInputType = 'select';
    }
    get page() {
        return this._page;
    }
    set page(value) {
        const oldValue = this._page;
        const numberValue = Number.parseInt(value, 10);
        if (!(numberValue < 1 || numberValue > this._totalPages || Number.isNaN(numberValue))) {
            this._page = numberValue;
        }
        this.requestUpdate('page', oldValue);
    }
    get itemsPerPage() {
        return this._itemsPerPage;
    }
    set itemsPerPage(value) {
        const oldValue = this._itemsPerPage;
        let numberValue = Number.parseInt(value, 10);
        if (numberValue < 1 || Number.isNaN(numberValue)) {
            numberValue = 1;
        }
        this._itemsPerPage = numberValue;
        if (this.page > this._totalPages) {
            this.page = 1;
        }
        this.requestUpdate('itemsPerPage', oldValue);
    }
    get _totalPages() {
        return Math.ceil(this.totalItems / this.itemsPerPage);
    }
    get _canGoBackward() {
        return this.page > 1;
    }
    get _canGoForward() {
        return !this.totalItems || this.page < this._totalPages;
    }
    get _itemsFrom() {
        return Math.max(1, this.page * this.itemsPerPage - (this.itemsPerPage - 1));
    }
    get _itemsTo() {
        return this.totalItems
            ? Math.min(this.totalItems, this.page * this.itemsPerPage)
            : this.page * this.itemsPerPage;
    }
    updated(_changedProps) {
        if ((_changedProps.has('page') && _changedProps.get('page') !== undefined) ||
            (_changedProps.has('itemsPerPage') && _changedProps.get('itemsPerPage') !== undefined)) {
            this.dispatchEvent(new CustomEvent('change', {
                detail: {
                    page: this.page,
                    itemsPerPage: this.itemsPerPage,
                    itemsFrom: this._itemsFrom,
                    itemsTo: this._itemsTo,
                },
                bubbles: true,
                composed: true,
            }));
        }
    }
    _onInputForPageChange(e) {
        this.page = e.target.value;
        e.target.value = this.page;
    }
    _onSelectForPageChange(e) {
        this.page = e.target.value;
    }
    _onSelectForItemsPerPageChange(e) {
        this.itemsPerPage = e.target.value;
    }
    backward() {
        if (this._canGoBackward) {
            this.page -= 1;
        }
    }
    forward() {
        if (this._canGoForward) {
            this.page += 1;
        }
    }
    renderOption(val, isSelected) {
        return html `<option value="${val}" ?selected="${isSelected}">${val}</option>`;
    }
    renderPageInput() {
        let output;
        if (this.totalItems && this.pageInputType === 'input') {
            output = html `<input
        type="number"
        ?disabled="${this.disabled}"
        class="input-page"
        .value="${this.page}"
        @change="${this._onInputForPageChange}"
        aria-label="page"
      />`;
        }
        else if (this.totalItems && this.pageInputType === 'select') {
            output = html `<select
        ?disabled="${this.disabled}"
        class="select-page"
        @change="${this._onSelectForPageChange}"
        .selectedIndex="${this.page - 1}"
        aria-label="page"
      >
        ${[...Array(this._totalPages)].map((_, idx) => this.renderOption(idx + 1, idx + 1 === this.page))}
      </select>`;
        }
        else {
            output = nothing;
        }
        return output;
    }
    renderItemsPerPageInput() {
        if (this.itemsPerPageValues && this.itemsPerPageValues.length) {
            return html `
        <select
          ?disabled="${this.disabled}"
          class="select-items-per-page"
          @change="${this._onSelectForItemsPerPageChange}"
          aria-label="items per page"
        >
          ${this.itemsPerPageValues.map(v => this.renderOption(v, v === this.itemsPerPage))}
        </select>
      `;
        }
        return nothing;
    }
    renderSeparator(context) {
        const anyContentInItemsPerPageArea = (this.itemsPerPageValues && this.itemsPerPageValues.length) || this.textBeforeItemsPerPage;
        const anyContentInItemsPerPageInfoArea = this.textAfterItemsPerPage;
        const isRenderItemsPerPageSep = context === 'itemsPerPageArea' &&
            anyContentInItemsPerPageArea &&
            anyContentInItemsPerPageInfoArea;
        const isRenderPageAreaSep = context === 'pageArea' && (anyContentInItemsPerPageArea || anyContentInItemsPerPageInfoArea);
        if (isRenderItemsPerPageSep || isRenderPageAreaSep) {
            return html `<span class="separator"></span>`;
        }
        return nothing;
    }
    renderLabel(text, classInfo) {
        if (text) {
            const args = {
                page: this.page,
                totalPages: this._totalPages,
                totalItems: this.totalItems,
                itemsPerPage: this.itemsPerPage,
                itemsFrom: this._itemsFrom,
                itemsTo: this._itemsTo,
            };
            return html ` <span class="${classMap(classInfo)}"> ${stringFormat(text, args)} </span>`;
        }
        return nothing;
    }
    render() {
        const cssClasses = {
            wrapper: { '-hds-pagination-wrapper': true, disabled: this.disabled },
            textBeforeItemsPerPage: {
                'text-before-items-per-page': true,
                'has-text': this.textBeforeItemsPerPage,
            },
            textAfterItemsPerPage: {
                'text-after-items-per-page': true,
                'has-text': this.textAfterItemsPerPage,
            },
            textBeforePage: { 'text-before-page': true, 'has-text': this.textBeforePage },
            textAfterPage: { 'text-after-page': true, 'has-text': this.textAfterPage },
            textBeforeNav: { 'text-before-nav': true, 'has-text': this.textBeforeNav },
            textAfterNav: { 'text-after-nav': true, 'has-text': this.textAfterNav },
        };
        return html `
      <div class="${classMap(cssClasses.wrapper)}">
        <div class="-items-per-page-wrapper">
          ${this.renderLabel(this.textBeforeItemsPerPage, cssClasses.textBeforeItemsPerPage)}
          ${this.renderItemsPerPageInput()} ${this.renderSeparator('itemsPerPageArea')}
          ${this.renderLabel(this.textAfterItemsPerPage, cssClasses.textAfterItemsPerPage)}
        </div>
        <div class="-pages-wrapper">
          ${this.renderSeparator('pageArea')}
          ${this.renderLabel(this.textBeforePage, cssClasses.textBeforePage)}
          ${this.renderPageInput()}
          ${this.renderLabel(this.textAfterPage, cssClasses.textAfterPage)}
          ${this.renderLabel(this.textBeforeNav, cssClasses.textBeforeNav)}
          <hds-button
            class="nav-backward"
            @click="${this.backward}"
            ?disabled="${!this._canGoBackward || this.disabled}"
            variant="secondary"
            size="small"
            icon="arrow-left"
          ></hds-button>
          <hds-button
            class="nav-forward"
            @click="${this.forward}"
            ?disabled="${!this._canGoForward || this.disabled}"
            variant="secondary"
            size="small"
            icon="arrow-right"
          ></hds-button>
          ${this.renderLabel(this.textAfterNav, cssClasses.textAfterNav)}
        </div>
      </div>
    `;
    }
};
Pagination.styles = styles;
__decorate([
    property({ type: Boolean })
], Pagination.prototype, "disabled", void 0);
__decorate([
    property({ type: Array, attribute: 'items-per-page-values' })
], Pagination.prototype, "itemsPerPageValues", void 0);
__decorate([
    property({ type: Number, attribute: 'total-items' })
], Pagination.prototype, "totalItems", void 0);
__decorate([
    property({ type: String, attribute: 'text-before-items-per-page' })
], Pagination.prototype, "textBeforeItemsPerPage", void 0);
__decorate([
    property({ type: String, attribute: 'text-after-items-per-page' })
], Pagination.prototype, "textAfterItemsPerPage", void 0);
__decorate([
    property({ type: String, attribute: 'text-before-page' })
], Pagination.prototype, "textBeforePage", void 0);
__decorate([
    property({ type: String, attribute: 'text-after-page' })
], Pagination.prototype, "textAfterPage", void 0);
__decorate([
    property({ type: String, attribute: 'text-before-nav' })
], Pagination.prototype, "textBeforeNav", void 0);
__decorate([
    property({ type: String, attribute: 'text-after-nav' })
], Pagination.prototype, "textAfterNav", void 0);
__decorate([
    property({ type: String, attribute: 'page-input-type' })
], Pagination.prototype, "pageInputType", void 0);
__decorate([
    property({ type: Number, reflect: true, attribute: 'page' })
], Pagination.prototype, "page", null);
__decorate([
    property({ type: Number, reflect: true, attribute: 'items-per-page' })
], Pagination.prototype, "itemsPerPage", null);
Pagination = __decorate([
    customElement('hds-pagination')
], Pagination);
export { Pagination };
//# sourceMappingURL=hds-pagination.js.map