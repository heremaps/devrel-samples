import { __decorate } from "tslib";
import { customElement, debounce } from '@here/hds-base';
import '@here/hds-button';
import { Modal } from '@here/hds-modal';
import '@here/hds-overlay';
import { Step, Stepper } from '@here/hds-stepper';
import { html, nothing } from 'lit';
import { property, query } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { unsafeHTML } from 'lit/directives/unsafe-html.js';
import { styles } from './hds-wizard.css.js';
/**
 * @slot header Content to be shown as title on the header
 * @slot body Main content of the modal
 * @slot footer Content to be shown on the footer below the body content
 * @slot stepper Content for the `hds-stepper` element
 * @slot stepper-footer Content for the footer section below the stepper
 *
 * @event {CustomEvent<{from: 'confirm' | 'cancel'}>} action Fired when click on one of the action buttons `WizardActionPayload`
 */
let Wizard = class Wizard extends Modal {
    constructor() {
        super(...arguments);
        this.stepperHeading = '';
        this.confirmText = 'Next';
        this.cancelText = 'Back';
        this.stepText = 'Step {{ activeStep }} of {{ totalSteps }}';
        this.debouncedResize = debounce(async () => {
            await super.changeBodyMaxHeight();
            await this.changeStepperMaxHeight();
        }, 150);
    }
    static get styles() {
        return [super.styles, styles];
    }
    get stepper() {
        let stepper;
        const nodes = this.slotNodes(this.stepperSlot)[0]?.childNodes;
        if (nodes) {
            stepper = [...nodes].find((element) => element instanceof Stepper);
        }
        return stepper;
    }
    async updated() {
        await super.updated();
        if (this.stepper) {
            this.stepper.orientation = 'vertical';
        }
        await super.changeBodyMaxHeight();
        await this.changeStepperMaxHeight();
    }
    render() {
        const classes = {
            dialog: true,
        };
        return html `
      <div class="-hds-wizard-wrapper -hds-modal-wrapper hds-grid-container ${classMap(classes)}">
        <div
          class="hds-wizard-content-wrapper wrapper hds-grid-container"
          role="dialog"
          aria-modal="true"
          aria-labelledby="title"
          aria-describedby="content"
        >
          <div class="stepper-wrapper">
            ${this.renderStepperHeading()}
            <div class="stepper">
              <slot name="stepper" @slotchange="${this.onSlotChange}"></slot>
            </div>

            ${this.renderStepperFooter()}
          </div>
          <div class="content-wrapper">
            ${this.renderContentHeader()}
            <div
              class="hds-modal-body"
              id="content"
              @scroll="${() => this.dispatchEvent(new CustomEvent('scroll', { composed: true, bubbles: true }))}"
            >
              <slot name="body"></slot>
              <slot>
                <div>${this.message}</div>
              </slot>
            </div>
            ${this.renderContentFooter()} ${this.renderCloseButton()}
          </div>
        </div>
        <hds-overlay @click="${this.handleClickOverlay}"></hds-overlay>
      </div>
    `;
    }
    async setTabbableElements() {
        await this.updateComplete;
        super.setTabbableElements();
        if (this.stepper && this.stepper.nonLinear) {
            const steps = [...this.stepper.childNodes].filter((node) => node instanceof Step);
            this.tabbableElements.unshift(...steps);
        }
        this.removeHandleFocusEvents();
        this.setTabKeydownListeners();
    }
    renderStepText() {
        return this.stepText
            .replace(/{{\s*activeStep\s*}}/, `<span id="current-step">${(this.stepper?.activeStep || 0) + 1}</span>`)
            .replace(/{{\s*totalSteps\s*}}/, `${this.stepper?.stepsLength}`);
    }
    /**
     * Set calculated max height for stepper as custom css variable
     */
    async changeStepperMaxHeight() {
        await this.updateComplete;
        const header = this.shadowRoot.querySelector('#stepper-heading');
        const footer = this.shadowRoot.querySelector('#stepper-footer');
        const documentHeight = this.shadowRoot.ownerDocument.body.offsetHeight;
        const headerHeight = header?.offsetHeight || 0;
        const footerHeight = footer?.offsetHeight || 0;
        const maxHeight = `${documentHeight - (headerHeight + footerHeight + this.HDS_SPACING_10 * 2)}px`;
        this.shadowRoot.ownerDocument.body.style.setProperty('--hds-wizard-stepper-max-height', maxHeight);
    }
    renderContentHeader() {
        if (this.hideHeader) {
            return nothing;
        }
        const classes = {
            'hds-modal-header': true,
        };
        const titleClasses = {
            title: true,
        };
        if (!this.headerSlotted && !this.headingMessage) {
            return html ` <slot name="header"></slot>`;
        }
        return html `
      <div id="modal-header" class="${classMap(classes)}">
        <div id="title" class="${classMap(titleClasses)}">
          <slot name="header">
            <div class="heading-counter">${unsafeHTML(this.renderStepText())}</div>
            ${this.headingMessage}
          </slot>
        </div>
      </div>
    `;
    }
    onSlotChange() {
        const stepsNode = this.slotNodes(this.stepperSlot)[0];
        const stepper = [...stepsNode.childNodes].filter((node) => node instanceof Stepper)[0];
        if (!stepper) {
            throw new Error('Stepper should be provided');
        }
    }
    renderStepperHeading() {
        if (this.stepperHeading) {
            return html ` <div id="stepper-heading" class="stepper-heading">${this.stepperHeading}</div>`;
        }
        return undefined;
    }
    renderStepperFooter() {
        return html ` <div id="stepper-footer" class="stepper-footer">
      <slot name="stepper-footer"></slot>
    </div>`;
    }
    renderContentFooter() {
        if (this.hideFooter) {
            return undefined;
        }
        return html `
      <div id="modal-footer" class="hds-modal-footer">
        <slot name="footer">${this.renderFooterButtons()}</slot>
      </div>
    `;
    }
    renderFooterButtons() {
        const confirm = this.hideConfirm
            ? undefined
            : this.renderDefaultFooterButton(this.confirmVariant, this.confirmText, 'confirm');
        const cancel = this.hideCancel
            ? undefined
            : this.renderDefaultFooterButton('secondary', this.cancelText, 'cancel');
        return html ` <div class="hds-modal-footer--default">${cancel}${confirm}</div>`;
    }
    renderDefaultFooterButton(variant, text, name) {
        return html ` <hds-button
      class="default-button ${name}"
      variant="${variant}"
      width="100%"
      @click="${() => this.defaultButtonClick(name)}"
      aria-label="${text}"
      size="small"
      >${text}
    </hds-button>`;
    }
    async defaultButtonClick(name) {
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('action', {
            detail: {
                from: name,
            },
        }));
    }
};
__decorate([
    property({ type: String, reflect: true, attribute: 'stepper-heading' })
], Wizard.prototype, "stepperHeading", void 0);
__decorate([
    property({ type: String, reflect: true, attribute: 'confirm-text' })
], Wizard.prototype, "confirmText", void 0);
__decorate([
    property({ type: String, reflect: true, attribute: 'cancel-text' })
], Wizard.prototype, "cancelText", void 0);
__decorate([
    property({
        type: String,
        reflect: true,
        attribute: 'step-text',
    })
], Wizard.prototype, "stepText", void 0);
__decorate([
    query('slot[name="stepper"]')
], Wizard.prototype, "stepperSlot", void 0);
Wizard = __decorate([
    customElement('hds-wizard')
], Wizard);
export { Wizard };
//# sourceMappingURL=hds-wizard.js.map