import { __decorate } from "tslib";
import { customElement } from '@here/hds-base';
import { html, LitElement } from 'lit';
import { property, query } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { StepConnector } from './hds-step-connector.js';
import { Step } from './hds-step.js';
import { styles } from './hds-stepper.css.js';
let stepperCounter = 0;
/**
 * @slot default Content for the `hds-step` elements
 *
 * @event {CustomEvent<{currentState: StepState; stepIndex: number}>} current-active-step Fired when a new step has been selected `StepperCurrentActiveStepPayload`
 *
 */
let Stepper = class Stepper extends LitElement {
    constructor() {
        super(...arguments);
        this.nonLinear = false;
        this.hideLabel = false;
        this.bottomLabel = false;
        this.orientation = 'horizontal';
        this.activeStep = 0;
        this.stepsLength = 0;
    }
    connectedCallback() {
        super.connectedCallback();
        this.id = this.id || `hds-stepper-${++stepperCounter}`;
        this.addEventListener('activate-step-internal', this._handleStepClick);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('activate-step-internal', this._handleStepClick);
    }
    reset() {
        const steps = this._getSteps();
        for (const step of steps) {
            step.state = 'disabled';
        }
        this.completeStep = undefined;
        this.activeStep = 0;
    }
    _handleStepClick({ detail }) {
        if (detail) {
            this.activeStep = detail.stepIndex;
        }
    }
    firstUpdated(_changedProperties) {
        super.firstUpdated(_changedProperties);
        this.setupStep();
    }
    async updated(_changedProperties) {
        super.updated(_changedProperties);
        this.stepsLength = this._getSteps().length;
        if (_changedProperties.has('activeStep')) {
            await this.activeStepUpdated(_changedProperties.get('activeStep'));
        }
        if (_changedProperties.has('completeStep')) {
            this.completeStepUpdated();
        }
        if (_changedProperties.has('errorStep')) {
            this.errorStepUpdated();
        }
    }
    async activeStepUpdated(oldVal) {
        const steps = this._getSteps();
        const value = this.activeStep;
        const selectedStep = steps[value];
        if (!selectedStep) {
            throw new Error('Invalid step index');
        }
        if (this.nonLinear) {
            for (const step of steps) {
                if (step.index !== value && step.state !== 'completed' && step.state !== 'error') {
                    step.state = 'disabled';
                }
            }
            if (selectedStep.state !== 'completed' && selectedStep.state !== 'error') {
                selectedStep.state = 'active';
            }
        }
        else {
            // RULES FOR LINEAR MODE
            // Below is the code for all ERROR case for skip and to check if last step is completed
            if (value !== 0 && value - oldVal > 0) {
                if ((value - oldVal === 2 && steps[oldVal + 1] && !steps[oldVal + 1]?.optional) ||
                    (value - oldVal === 1 && steps[value - 2] && steps[value - 2].state !== 'completed') ||
                    value - oldVal > 2) {
                    this.activeStep = oldVal;
                    throw new Error('In linear mode, you can only activate this step if the last step is completed or optional');
                }
            }
            // Below is the code for changing states base on direction
            if (value > oldVal && steps[oldVal]) {
                steps[oldVal].state = 'completed';
            }
            else if (value < oldVal && steps[oldVal]) {
                steps[oldVal].state = 'disabled';
            }
            // Finally setting selectedStep active
            selectedStep.state = 'active';
        }
        this.dispatchEvent(new CustomEvent('current-active-step', {
            detail: {
                currentState: selectedStep.state,
                stepIndex: value,
            },
            bubbles: true,
            composed: true,
        }));
    }
    completeStepUpdated() {
        if (this.completeStep === undefined)
            return;
        const steps = this._getSteps();
        const selectedStep = steps[this.completeStep];
        if (!selectedStep) {
            throw new Error('Invalid step index');
        }
        else if (selectedStep.state !== 'active' && selectedStep.state !== 'error') {
            throw new Error('You can only complete the currently active or errored step');
        }
        else {
            selectedStep.state = 'completed';
        }
        // completeStep set to default/ undefined to allow updates for exceptions when same value is set again.
        this.completeStep = undefined;
    }
    errorStepUpdated() {
        if (this.errorStep === undefined)
            return;
        const steps = this._getSteps();
        const selectedStep = steps[this.errorStep];
        if (!selectedStep) {
            throw new Error('Invalid step index');
        }
        if (!this.nonLinear) {
            throw new Error("Step can't be set in error state in Linear mode");
        }
        selectedStep.state = 'error';
        this.errorStep = undefined;
    }
    setupStep() {
        const steps = this._getSteps();
        for (let i = 0; i < steps.length; i += 1) {
            steps[i].index = i;
            steps[i].bottomLabel = this.bottomLabel;
            steps[i].orientation = this.orientation;
            steps[i].hideLabel = this.hideLabel;
            steps[i].nonLinear = this.nonLinear;
            if (i === 0) {
                steps[i].state = 'active';
            }
            else if (i !== 0) {
                steps[i].state = 'disabled';
                if (this.orientation === 'vertical' || !this.bottomLabel) {
                    const stepConnector = new StepConnector();
                    stepConnector.bottomLabel = this.bottomLabel;
                    stepConnector.orientation = this.orientation;
                    steps[i]?.parentNode?.insertBefore(stepConnector, steps[i]);
                }
            }
        }
    }
    render() {
        const classes = {
            'hds-stepper--label-bottom': this.orientation === 'horizontal' && this.bottomLabel,
            [`hds-stepper--orientation-${this.orientation}`]: true,
        };
        return html `
      <div role="group" aria-label="progress" class="hds-stepper-wrapper ${classMap(classes)}">
        <slot></slot>
      </div>
    `;
    }
    _getSteps() {
        return this.stepsSlot
            .assignedNodes({ flatten: true })
            .filter((e) => e instanceof Step);
    }
};
Stepper.styles = styles;
__decorate([
    property({ type: Boolean, attribute: 'non-linear' })
], Stepper.prototype, "nonLinear", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-label' })
], Stepper.prototype, "hideLabel", void 0);
__decorate([
    property({ type: Boolean, attribute: 'bottom-label' })
], Stepper.prototype, "bottomLabel", void 0);
__decorate([
    property({ type: String })
], Stepper.prototype, "orientation", void 0);
__decorate([
    property({ type: Number, reflect: true, attribute: 'active-step' })
], Stepper.prototype, "activeStep", void 0);
__decorate([
    property({ type: Number, reflect: true, attribute: 'complete-step' })
], Stepper.prototype, "completeStep", void 0);
__decorate([
    property({ type: Number, reflect: true, attribute: 'error-step' })
], Stepper.prototype, "errorStep", void 0);
__decorate([
    property({ type: Number, attribute: false })
], Stepper.prototype, "stepsLength", void 0);
__decorate([
    query('slot')
], Stepper.prototype, "stepsSlot", void 0);
Stepper = __decorate([
    customElement('hds-stepper')
], Stepper);
export { Stepper };
//# sourceMappingURL=hds-stepper.js.map