/**
 * Rounds a number to the nearest of a specified value.
 *
 * @param {number} x - The number to be rounded.
 * @param {number} [nearest=0.0] - The nearest value to round to. Defaults to 0.0 if not provided.
 * @returns {number} The number rounded to the nearest specified value.
 */
export function roundToNearest(x, nearest = 0.0) {
    return nearest === 0 ? x : Math.round(x / nearest) * nearest;
}
/**
 * Scales a number from one range to another.
 *
 * @param {number} x - The number to be scaled.
 * @param {number} xMin - The minimum value of the original range.
 * @param {number} xMax - The maximum value of the original range.
 * @param {number} [xNewMin=0] - The minimum value of the new range (default is 0).
 * @param {number} [xNewMax=1] - The maximum value of the new range (default is 1).
 * @returns {number} - The scaled number.
 */
export function scale(x, xMin, xMax, xNewMin = 0, xNewMax = 1) {
    return (xNewMax - xNewMin) * ((x - xMin) / (xMax - xMin)) + xNewMin;
}
/**
 * Clamp function that check that a number `x` in between the bounds `[min, max]`
 *
 * @param x - Number to check
 * @param min - Minimum bound
 * @param max - Maximum bound
 * @return `min` if `x <= min`, `x` if `min < x < max`, `max` if `x >= max`
 */
export function clamp(x, min, max) {
    if (Number.isNaN(x))
        return NaN;
    return Math.min(Math.max(x, min), max);
}
/**
 * Simple debounce function, so it is called once every given time.
 * Useful to use with events like resize, mousemove, etc.
 *
 * @template T extends unknown[] - Type of functions
 * @template U - callback function
 * @param callback - callback function to be debounced
 * @param wait - wait number in milliseconds
 * @returns the debounced function
 */
export function debounce(callback, wait) {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        return new Promise(resolve => {
            timer = setTimeout(() => resolve(callback(...args)), wait);
        });
    };
}
/**
 * Simple throttle function that limits the execution of a function to once in every specified time interval.
 *
 * @template T extends unknown[] - Type of functions
 * @template U - callback function
 * @param callback - callback function to be throttled
 * @param wait - wait number in milliseconds
 * @returns the throttled function
 */
export function throttle(callback, wait) {
    let lastTime = 0;
    let timer;
    return (...args) => new Promise(resolve => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            if (Date.now() - lastTime >= wait) {
                resolve(callback(...args));
                lastTime = Date.now();
            }
        }, Math.max(0, wait - (Date.now() - lastTime)));
    });
}
/**
 * Find the closest element with a given selector up to dom from the base element
 *
 * @param selector - selector for element to be found
 * @param base - the element from which the search starts
 * @returns first element found by selector or null if not found
 */
export function closestElement(selector, base) {
    function findClosest(el) {
        if (!el || el === document || el === window) {
            return null;
        }
        const found = el.closest(selector);
        return found || findClosest(el.getRootNode().host);
    }
    return findClosest(base);
}
/**
 * Get the value of a CSS Variable for a given HTML Element.
 * If not HTML Element is passed it will take the first element with
 * the attribute `[data-theme^=hds]`
 *
 * @param name - name of the CSS variable
 * @param el - HTMLElement to get the CSS variable from, fallback to first `[data-theme]` element if `undefined`
 * @returns The value of the CSS Variable
 */
export function getCSSVariable(name, el) {
    const htmlElement = el || document.querySelector('[data-theme^=hds]');
    return getComputedStyle(htmlElement)?.getPropertyValue(name).trim();
}
/**
 * Returns if a given slot or and array of nodes are empty
 *
 * @param slotOrNodes - Slot element or array of nodes to be inspected
 * @returns `true` if slot is empty or `false` if contains any kind of nodes
 */
export function isSlotEmpty(slotOrNodes) {
    let isEmpty = true;
    if (slotOrNodes) {
        const nodes = slotOrNodes instanceof HTMLSlotElement
            ? slotOrNodes.assignedNodes({ flatten: true })
            : slotOrNodes;
        for (let n = 0; n < nodes.length; n += 1) {
            const isWebComponent = nodes[n] instanceof HTMLElement && nodes[n].tagName.indexOf('-') !== -1;
            const hasAnyContent = nodes[n].textContent.trim() !== '';
            if (hasAnyContent || isWebComponent) {
                isEmpty = false;
                break;
            }
        }
    }
    return isEmpty;
}
/**
 * Decorator to define the class in the browser's custom elements registry for a given element tag name.
 * It checks if the tag already exists. If it does it behaves depending on the configuration parameters.
 *
 * @param tagName - name of the tag for the element class
 * @returns The decorated class
 */
export const customElement = (tagName) => (ctor) => {
    if (typeof window !== 'undefined') {
        const settings = window.hds || {};
        const disableAutoCustomElementsDefine = !!settings.disableAutoCustomElementsDefine;
        if (!disableAutoCustomElementsDefine) {
            const tryGetBeforeCustomElementsDefine = !!settings.tryGetBeforeCustomElementsDefine;
            if (!tryGetBeforeCustomElementsDefine ||
                (tryGetBeforeCustomElementsDefine && !window.customElements.get(tagName))) {
                window.customElements.define(tagName, ctor);
            }
        }
    }
};
/**
 * Format string template by passed arguments
 *
 * @param template - original string template
 * @param args - arguments for replacement
 * @param keepNotMatched - if true will keep all unresolved params
 * @example stringFormat('hello {0}', {0: 'world'}) => 'hello world'
 * @example stringFormat('hello {name}', {name: 'Dmytro'}) => 'hello Dmytro'
 * @example stringFormat('hello {world} {name}', {name: 'Dmytro'}, true) => 'hello {world} Dmytro'
 * @returns - formatted string
 */
export const stringFormat = (template, args, keepNotMatched = false) => {
    if (template) {
        const argsKeysArray = Object.keys(args);
        const replacer = (_, match) => {
            let valueByName = args[match];
            let valueByIndex = args[argsKeysArray[match]];
            valueByName = typeof valueByName === 'number' ? valueByName.toString() : valueByName;
            valueByIndex = typeof valueByIndex === 'number' ? valueByIndex.toString() : valueByIndex;
            const originalValue = keepNotMatched ? `{${match}}` : '';
            const formatted = valueByName || valueByIndex || originalValue;
            return formatted;
        };
        return template.replace(/{([a-zA-Z0-9]+)}/g, replacer);
    }
    return template;
};
/**
 * Find the HTML elements of a given type recursively inside a slot
 *
 * @param slot - Slot to find the element
 * @param filterType - Class of the element to Find
 * @example findElementsInSlot(this.shadowRoot!.querySelector('slot'), ListItem)
 * @returns - Array with elements of the given type
 */
export function findElementsInSlot(slot, filterType) {
    const results = [];
    if (!slot)
        return results;
    const elements = slot.assignedElements({ flatten: true });
    elements.forEach(node => {
        if (node instanceof filterType)
            results.push(node);
        results.push(...Array.from(node.querySelectorAll('*')).filter(e => e instanceof filterType));
    });
    return results;
}
//# sourceMappingURL=utils.js.map