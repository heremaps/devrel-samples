import { __decorate } from "tslib";
/* eslint max-classes-per-file: ["error", 2] */
import { html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { SwitcherTab } from './hds-switcher-tab.js';
import { styles } from './hds-switcher.css.js';
/**
 * @slot default Content for the `hds-switcher-tab` elements
 *
 * @event {CustomEvent<object>} select Fired when one of the items has been selected  `SwitcherSelectPayload`
 */
let Switcher = class Switcher extends LitElement {
    constructor() {
        super(...arguments);
        this._tabs = [];
        this.disabled = false;
        this.variant = 'subtle';
        this.size = 'medium';
    }
    firstUpdated() {
        this.onSlotChange();
    }
    updated(_changedProperties) {
        if (_changedProperties.has('size') ||
            _changedProperties.has('variant') ||
            _changedProperties.has('disabled')) {
            this.updateTabs();
        }
    }
    async _onSelect(e) {
        e.stopPropagation();
        let selectedIndex = -1;
        for (let t = 0; t < this._tabs.length; t += 1) {
            if (this._tabs[t] === e.target) {
                selectedIndex = t;
            }
            else {
                this._tabs[t].selected = false;
            }
        }
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('select', {
            detail: { id: e.detail, index: selectedIndex },
            bubbles: true,
            composed: true,
        }));
    }
    selectFirstNotDisabled() {
        if (this.disabled)
            return;
        let firstNonDisabledNonSelected = -1;
        let firstNonDisabledSelected = -1;
        for (let t = 0; t < this._tabs.length; t += 1) {
            const { selected, disabled } = this._tabs[t];
            if (!selected && !disabled && firstNonDisabledNonSelected === -1) {
                firstNonDisabledNonSelected = t;
            }
            if (selected && !disabled && firstNonDisabledSelected === -1) {
                firstNonDisabledSelected = t;
            }
            if (selected &&
                (disabled || (firstNonDisabledSelected > -1 && firstNonDisabledSelected !== t))) {
                this._tabs[t].selected = false;
            }
        }
        if (firstNonDisabledNonSelected > -1 && firstNonDisabledSelected === -1) {
            this._tabs[firstNonDisabledNonSelected].selected = true;
        }
    }
    updateTabs() {
        for (let t = 0; t < this._tabs.length; t += 1) {
            this._tabs[t].switcherSize = this.size;
            this._tabs[t].switcherVariant = this.variant;
            this._tabs[t].switcherDisabled = this.disabled;
            this._tabs[t].isFirstChild = t === 0;
            this._tabs[t].isLastChild = t === this._tabs.length - 1;
        }
    }
    async onSlotChange() {
        this._tabs = Array.from(this.querySelectorAll('*')).filter(e => e instanceof SwitcherTab);
        this.updateTabs();
        this.selectFirstNotDisabled();
    }
    _onKeyDown(e) {
        const { activeElement: focused } = this.ownerDocument;
        if (!(e.key === 'ArrowRight' || e.key === 'ArrowLeft') || !(focused instanceof SwitcherTab)) {
            return;
        }
        let before;
        let after;
        let current;
        for (let t = 0; t < this._tabs.length; t += 1) {
            if (e.key === 'ArrowRight' && current && after)
                break;
            if (e.key === 'ArrowLeft' && current && before)
                break;
            const { disabled } = this._tabs[t];
            if (!current && this._tabs[t] === focused) {
                current = this._tabs[t];
            }
            if (!disabled && !current && this._tabs[t] !== focused) {
                before = this._tabs[t];
            }
            if (!disabled && current && !after && this._tabs[t] !== focused) {
                after = this._tabs[t];
            }
        }
        if (e.key === 'ArrowRight' && after)
            after.focus();
        else if (e.key === 'ArrowLeft' && before)
            before.focus();
    }
    render() {
        const classes = {
            '-hds-switcher-wrapper': true,
            disabled: this.disabled,
        };
        classes[`hds-switcher-variant-${this.variant}`] = true;
        classes[`hds-switcher-size-${this.size}`] = true;
        return html `
      <div
        .ariaLabel="${this.ariaLabel}"
        .role="${'radiogroup'}"
        class="${classMap(classes)}"
        @select="${this._onSelect}"
        @keydown="${this._onKeyDown}"
        ?disabled="${this.disabled}"
      >
        <slot @slotchange="${this.onSlotChange}"></slot>
      </div>
    `;
    }
};
Switcher.styles = styles;
__decorate([
    property({ type: Boolean, reflect: true })
], Switcher.prototype, "disabled", void 0);
__decorate([
    property({ type: String, reflect: true })
], Switcher.prototype, "variant", void 0);
__decorate([
    property({ type: String, reflect: true })
], Switcher.prototype, "size", void 0);
Switcher = __decorate([
    customElement('hds-switcher')
], Switcher);
export { Switcher };
//# sourceMappingURL=hds-switcher.js.map