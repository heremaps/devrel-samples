var Chip_1;
import { __decorate } from "tslib";
import { customElement, BaseElement, getCSSVariable } from '@here/hds-base';
import '@here/hds-icon';
import '@here/hds-tooltip';
import { html, nothing, LitElement } from 'lit';
import { property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styles } from './hds-chip.css.js';
/**
 *
 * @slot default Content for the chip label
 * @slot image Content for the image. Can be an `img` or `hds-icon` or `hds-avatar` element
 *
 * @event {CustomEvent} remove Fired when the remove button has been clicked
 * @event {CustomEvent<ChipSelectPayload>} select Fired when the chip has been clicked with the selected information `ChipSelectPayload`
 *
 * @cssprop --hds-chip-max-width Set the maximum width for the chip
 * @cssprop --hds-chip-image-border-color Sets the border color for the image to match the background
 *
 */
let Chip = Chip_1 = class Chip extends BaseElement {
    constructor() {
        super(...arguments);
        this.size = 'medium';
        this.disabled = false;
        this.selected = false;
        this.dragging = false;
        this.order = 0;
        this.status = 'neutral';
        this.removable = false;
        this.image = false;
        this.icon = false;
        this.avatar = false;
        this.tooltip = false;
        this.selectable = false;
        this.removeButtonFocused = false;
        this.isTabbable = true;
    }
    connectedCallback() {
        super.connectedCallback();
        this.id = this.id || `hds-chip-item-${++Chip_1.chipIdCounter}`;
        this.setAttribute('data-hds-tooltip', this.id);
    }
    addEventListener(type, listener, options) {
        if (type === 'remove') {
            this.removable = true;
        }
        super.addEventListener(type, listener, options);
    }
    firstUpdated(_changedProperties) {
        const slot = this.shadowRoot.querySelectorAll('slot')[0];
        const nodes = slot.assignedNodes();
        this.image = nodes.length >= 1;
        this.icon = this.image && nodes[0].nodeName.toLowerCase() === 'hds-icon';
        if (this.image && nodes[0].nodeName.toLowerCase() === 'hds-avatar') {
            const item = nodes[0];
            this.avatar = true;
            if (!item.borderless) {
                item.borderless = true;
            }
        }
        if (this.isTextOverflowing()) {
            this.tooltip = true;
        }
    }
    updated(_changedProperties) {
        super.updated(_changedProperties);
        if (_changedProperties.has('selected') && _changedProperties.get('selected') !== undefined) {
            this.dispatchEvent(new CustomEvent('select', { detail: this.selected }));
        }
    }
    render() {
        const classes = {
            dragging: this.dragging,
            disabled: this.disabled,
            selected: this.selected,
            unselected: !this.selected,
            removable: this.removable,
            selectable: this.selectable,
            clickable: this.selectable || this.removable,
            unclickable: !this.selectable && !this.removable,
            'with-image': this.image,
            'with-avatar': this.avatar,
            'with-icon': this.icon,
        };
        classes[this.size] = true;
        classes[this.status] = true;
        return html `
      <div style="order: ${this.order}">
        <button
          tabindex="-1"
          class="-hds-chip-wrapper ${classMap(classes)}"
          @click="${this._toggleSelect}"
          @focus="${this._focus}"
          @blur="${this._blur}"
          ?disabled="${this.disabled}"
          aria-disabled="${this.disabled}"
        >
          ${this.renderImageOrIcon()} ${this.renderLabel()} ${this.renderCloseIcon()}
        </button>
        ${this.renderTooltip()}
      </div>
    `;
    }
    isTextOverflowing() {
        const maxWidthToken = getCSSVariable('--hds-chip-max-width', this);
        const baseline = parseFloat(getCSSVariable('--hds-font-baseline', this));
        let maxWidth = 100;
        if (maxWidthToken.includes('px')) {
            maxWidth = parseFloat(maxWidthToken);
        }
        else if (maxWidthToken.includes('rem')) {
            maxWidth = parseFloat(maxWidthToken) * baseline;
        }
        return maxWidth < this.labelEl.scrollWidth;
    }
    removeButtonClick(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        const event = new CustomEvent('remove', {
            composed: true,
            bubbles: true,
        });
        this.dispatchEvent(event);
    }
    renderImageOrIcon() {
        return html ` <slot name="image" class="image" role="img" aria-labelledby="chip-label"></slot> `;
    }
    renderLabel() {
        return html `
      <div class="label" id="chip-label">
        <slot></slot>
      </div>
    `;
    }
    renderCloseIcon() {
        if (this.removable) {
            return html `
        <button
          class="remove"
          aria-label="Remove"
          ?disabled="${this.disabled}"
          @click="${this.removeButtonClick}"
        >
          <hds-icon name="cross" size="16px"></hds-icon>
        </button>
      `;
        }
        return nothing;
    }
    renderTooltip() {
        if (this.tooltip && this.chipLabelSlot) {
            return html `
        <hds-tooltip id="${this.id}">
          <div>${this.chipLabelSlot.assignedNodes()[0]?.textContent}</div>
        </hds-tooltip>
      `;
        }
        return nothing;
    }
    _toggleSelect() {
        if (!this.selectable || this.disabled || this.dragging || this.status !== 'neutral') {
            return;
        }
        this.selected = !this.selected;
    }
    _focus() {
        this.chipWrapper.setAttribute('tabindex', '0');
    }
    _blur() {
        this.chipWrapper.setAttribute('tabindex', '-1');
    }
};
Chip.styles = styles;
Chip.chipIdCounter = 0;
Chip.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
__decorate([
    property({ type: String })
], Chip.prototype, "size", void 0);
__decorate([
    property({ type: Boolean })
], Chip.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], Chip.prototype, "selected", void 0);
__decorate([
    property({ type: Boolean })
], Chip.prototype, "dragging", void 0);
__decorate([
    property({ type: Number, attribute: 'order' })
], Chip.prototype, "order", void 0);
__decorate([
    property({ type: String })
], Chip.prototype, "status", void 0);
__decorate([
    property({ type: Boolean })
], Chip.prototype, "removable", void 0);
__decorate([
    property({ type: Boolean, attribute: false })
], Chip.prototype, "image", void 0);
__decorate([
    property({ type: Boolean, attribute: false })
], Chip.prototype, "icon", void 0);
__decorate([
    property({ type: Boolean, attribute: false })
], Chip.prototype, "avatar", void 0);
__decorate([
    property({ type: Boolean, attribute: false })
], Chip.prototype, "tooltip", void 0);
__decorate([
    property({ type: Boolean })
], Chip.prototype, "selectable", void 0);
__decorate([
    state()
], Chip.prototype, "removeButtonFocused", void 0);
__decorate([
    query('#chip-label slot')
], Chip.prototype, "chipLabelSlot", void 0);
__decorate([
    query('#chip-label')
], Chip.prototype, "labelEl", void 0);
__decorate([
    query('.-hds-chip-wrapper')
], Chip.prototype, "chipWrapper", void 0);
Chip = Chip_1 = __decorate([
    customElement('hds-chip')
], Chip);
export { Chip };
//# sourceMappingURL=hds-chip.js.map