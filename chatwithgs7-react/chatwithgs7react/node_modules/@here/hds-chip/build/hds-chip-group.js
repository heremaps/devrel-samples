import { __decorate } from "tslib";
import { customElement } from '@here/hds-base';
import { html, LitElement } from 'lit';
import { property, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { styles } from './hds-chip-group.css.js';
import { Chip } from './hds-chip.js';
let ChipGroup = class ChipGroup extends LitElement {
    constructor() {
        super(...arguments);
        this.valign = 'center';
        this.justify = 'flex-start';
        this.dragging = false;
        this._draggingStartX = 0;
        this._draggingStartY = 0;
    }
    _onSlotChange() {
        this.updateItemsOrder();
    }
    _onMouseEvent(e) {
        if (!this.dragging) {
            return;
        }
        if (e.type === 'mousedown' && e.target instanceof Chip) {
            this._draggingSource = e.target;
            this._draggingStartX = e.clientX;
            this._draggingStartY = e.clientY;
            this._draggingSource.style.zIndex = '1';
        }
        else if (e.type === 'mousemove' && this._draggingSource !== undefined) {
            this._draggingSource.dragging = true;
            const bbox = this._draggingSource.getBoundingClientRect();
            const window = this.ownerDocument.defaultView;
            const containerX = bbox.right + (window.scrollX || 0);
            const containerY = bbox.top + (window.scrollY || 0);
            const itemMouseOffsetX = this._draggingStartX - bbox.right;
            const itemMouseOffsetY = this._draggingStartY - bbox.top;
            const translateX = e.pageX - containerX - itemMouseOffsetX;
            const translateY = e.pageY - containerY - itemMouseOffsetY;
            this._draggingSource.style.transform = `translate(${translateX}px, ${translateY}px)`;
        }
        else if (e.type === 'mouseup' && this._draggingSource !== undefined) {
            if (this._draggingSource.selectable) {
                this._draggingSource.selected =
                    this._draggingSource.style.transform === ''
                        ? this._draggingSource.selected
                        : !this._draggingSource.selected;
            }
            const elementsFromPoint = this.ownerDocument.elementsFromPoint(e.clientX, e.clientY);
            for (let i = 0; i < elementsFromPoint.length; i += 1) {
                if (elementsFromPoint[i] !== this._draggingSource && elementsFromPoint[i] instanceof Chip) {
                    const draggingTarget = elementsFromPoint[i];
                    const sourceOrder = this._draggingSource.order;
                    const targetOrder = draggingTarget.order;
                    this._draggingSource.order = targetOrder;
                    draggingTarget.order = sourceOrder;
                    break;
                }
            }
        }
        if ((e.type === 'mouseup' || e.type === 'mouseleave') && this._draggingSource !== undefined) {
            this._draggingSource.dragging = false;
            this._draggingSource.style.transform = '';
            this._draggingSource.style.zIndex = '0';
            this._draggingSource = undefined;
        }
    }
    render() {
        const stylesEl = {
            'align-items': this.valign,
            'justify-content': this.justify,
        };
        return html `
      <div
        @mouseleave="${this._onMouseEvent}"
        @mousedown="${this._onMouseEvent}"
        @mouseup="${this._onMouseEvent}"
        @mousemove="${this._onMouseEvent}"
        @keydown="${this.onKeyDown}"
        class="-hds-chip-group-wrapper"
        style="${styleMap(stylesEl)}"
      >
        <slot @slotchange="${this._onSlotChange}"></slot>
      </div>
    `;
    }
    getItems() {
        return this.slotElement
            .assignedNodes({ flatten: true })
            .filter((e) => e instanceof Chip);
    }
    updateItemsOrder() {
        const items = this.getItems();
        for (let i = 0; i < items.length; i += 1) {
            items[i].order = i;
        }
    }
    onKeyDown(e) {
        if (!(e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
            return;
        }
        const currActiveElement = this.ownerDocument.activeElement;
        const items = this.getItems();
        if (currActiveElement instanceof Chip && items.length > 0) {
            let { order } = currActiveElement;
            const dir = e.key === 'ArrowRight' ? 1 : -1;
            order = (order + dir) % items.length;
            order = order < 0 ? items.length - 1 : order;
            for (let i = 0; i < items.length; i += 1) {
                if (items[i].order === order) {
                    items[i].focus();
                    break;
                }
            }
        }
    }
};
ChipGroup.styles = styles;
ChipGroup.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
__decorate([
    property({ type: String })
], ChipGroup.prototype, "valign", void 0);
__decorate([
    property({ type: String })
], ChipGroup.prototype, "justify", void 0);
__decorate([
    property({ type: Boolean })
], ChipGroup.prototype, "dragging", void 0);
__decorate([
    query('slot')
], ChipGroup.prototype, "slotElement", void 0);
ChipGroup = __decorate([
    customElement('hds-chip-group')
], ChipGroup);
export { ChipGroup };
//# sourceMappingURL=hds-chip-group.js.map