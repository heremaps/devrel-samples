var Input_1;
import { __decorate } from "tslib";
import { clamp, customElement, isSlotEmpty } from '@here/hds-base';
import { Icon } from '@here/hds-icon';
import '@here/hds-label';
import { html, LitElement, nothing } from 'lit';
import { property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styles } from './hds-input.css.js';
/**
 * @slot right Content for custom actions on the right side
 * @slot left Content for custom actions on the left side
 *
 * @event {CustomEvent<{action: string}>} action Fired when one of the action elements has been clicked `InputActionPayload`
 * @event {CustomEvent<{value: number | string}>} input Fired when the value of the element has changed `InputInputPayload`
 * @event {CustomEvent<{value: number | string}>} change Fired when an alteration to the element's value is committed by the user `InputChangePayload`
 * @event {CustomEvent<Input>} focus Fired when the element has focus
 * @event {CustomEvent<Input>} blur Fired when the element loses focus
 * @event {KeyboardEvent} keydown Fired when a key is pressed
 * @event {KeyboardEvent} keyup Fired when a key is released
 *
 */
let Input = Input_1 = class Input extends LitElement {
    constructor() {
        super(...arguments);
        this.type = 'text';
        this.id = '';
        this.size = 'medium';
        this.iconCategory = 'core-ui';
        this.disabled = false;
        this.readonly = false;
        this.required = false;
        this.autofocus = false;
        this.minlength = -1;
        this.maxlength = -1;
        this.step = 1;
        this.charCounter = false;
        this.error = false;
        this.passwordVisibility = 'masked';
        this.autocomplete = '';
        this._value = '';
        this._min = Number.NEGATIVE_INFINITY;
        this._max = Number.POSITIVE_INFINITY;
        this.slotLeftHasContent = false;
        this.slotRightHasContent = false;
    }
    get value() {
        return this._value;
    }
    get min() {
        return this._min;
    }
    get max() {
        return this._max;
    }
    set value(val) {
        const oldValue = this._value;
        if (this.type === 'number') {
            const numericVal = clamp(parseInt(val, 10), this.min, this.max);
            this._value = Number.isNaN(numericVal) ? val : numericVal;
        }
        else {
            this._value = val;
        }
        this.requestUpdate('value', oldValue);
    }
    set min(val) {
        const oldValue = this._min;
        const numberValue = Number.parseInt(val, 10);
        const isNotANumber = Number.isNaN(numberValue) || (val === 0 && this.getAttribute('min') === '');
        this._min = isNotANumber ? Number.NEGATIVE_INFINITY : numberValue;
        this.requestUpdate('min', oldValue);
    }
    set max(val) {
        const oldValue = this._max;
        const numberValue = Number.parseInt(val, 10);
        const isNotANumber = Number.isNaN(numberValue) || (val === 0 && this.getAttribute('max') === '');
        this._max = isNotANumber ? Number.POSITIVE_INFINITY : numberValue;
        this.requestUpdate('max', oldValue);
    }
    get charCounterVisible() {
        return this.charCounter && this.maxlength !== -1;
    }
    get errorTextVisible() {
        return this.error && !!this.errorText;
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback();
        Input_1.idCounter += 1;
        if (this.label) {
            this.labelId = `hds-input-label-${Input_1.idCounter}`;
        }
        this.initialType = this.type;
    }
    firstUpdated() {
        this.onActionSlotChange();
        this.autofocus && this.focus();
    }
    updated(_changedProps) {
        if (_changedProps.has('value') && _changedProps.get('value') !== undefined) {
            this.inputElement.value = this.value;
        }
    }
    async clear() {
        this.value = '';
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('change', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    focus() {
        this.inputElement.focus();
    }
    blur() {
        this.inputElement.blur();
    }
    togglePassword() {
        if (this.disabled || !this._isPasswordVisibilityEnabled()) {
            return;
        }
        this.passwordVisibility = this.passwordVisibility === 'masked' ? 'text' : 'masked';
        this.type = this.passwordVisibility === 'masked' ? 'password' : 'text';
    }
    async stepUp(n) {
        if (this.type !== 'number' || this.disabled)
            return;
        await this._changeByStep(n || this.step);
    }
    async stepDown(n) {
        if (this.type !== 'number' || this.disabled)
            return;
        await this._changeByStep(-1 * (n || this.step));
    }
    setSelectionRange(start, end, direction) {
        this.inputElement.setSelectionRange(start, end, direction);
    }
    setRangeText(replacement, start, end, selectionMode) {
        if (start && end) {
            this.inputElement.setRangeText(replacement, start, end, selectionMode);
        }
        else {
            this.inputElement.setRangeText(replacement);
        }
        this.value = this.inputElement.value;
    }
    checkValidity() {
        return this.inputElement.checkValidity();
    }
    reportValidity() {
        return this.inputElement.reportValidity();
    }
    select() {
        this.inputElement.select();
    }
    setCustomValidity(error) {
        this.inputElement.setCustomValidity(error);
    }
    async onActionClick(e) {
        e.stopPropagation();
        const action = e.target.getAttribute('data-action') ||
            (e.target instanceof Icon && e.target.name) ||
            'custom';
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('action', {
            detail: { action },
            bubbles: true,
            composed: true,
        }));
    }
    renderSlotLeft() {
        return html `<div class="slot-left-wrapper">
      <slot
        name="left"
        @slotchange="${this.onActionSlotChange}"
        @click="${this.onActionClick}"
      ></slot>
    </div>`;
    }
    renderSlotRight() {
        return html `<div class="slot-right-wrapper">
      <slot
        name="right"
        @slotchange="${this.onActionSlotChange}"
        @click="${this.onActionClick}"
      ></slot>
    </div>`;
    }
    async onActionSlotChange() {
        this.slotLeftHasContent = !isSlotEmpty(this.slotLeft);
        this.slotRightHasContent = !isSlotEmpty(this.slotRight);
    }
    render() {
        const classes = {
            disabled: this.disabled,
            readonly: this.readonly,
            required: this.required,
            error: this.error,
            '-icon': this.icon,
            '-slot-left-has-content': this.slotLeftHasContent,
            '-slot-right-has-content': this.slotRightHasContent,
        };
        classes[`-${this.size}`] = true;
        return html `
      <div class="wrapper">
        ${this.renderLabel()}
        <div class="input-wrapper ${classMap(classes)}">
          ${this.renderIcon()} ${this.renderSlotLeft()} ${this.renderInput()}
          ${this.renderSlotRight()} ${this._renderIconControls()}
        </div>
        ${this.renderHelperText()}
      </div>
    `;
    }
    getAriaLabelledBy() {
        if (this.label)
            return this.labelId;
        if (this.ariaLabelledby)
            return this.ariaLabelledby;
        return undefined;
    }
    renderInput() {
        const classes = {
            'input-width-with-icon': this.type === 'number' || this.type === 'search' || this._isPasswordVisibilityEnabled(),
        };
        return html `
      <input
        .value="${this.value}"
        autocomplete="${ifDefined(this.autocomplete || undefined)}"
        type="${this.type}"
        id="${ifDefined(this.id === '' ? undefined : this.id)}"
        name="${ifDefined(this.name === '' ? undefined : this.name)}"
        placeholder="${ifDefined(this.placeholder === '' ? undefined : this.placeholder)}"
        ?required="${this.required}"
        ?disabled="${this.disabled}"
        ?readonly="${this.readonly}"
        minlength="${ifDefined(this.minlength === -1 ? undefined : this.minlength)}"
        maxlength="${ifDefined(this.maxlength === -1 ? undefined : this.maxlength)}"
        min="${ifDefined(this.type !== 'number' ? undefined : this.min)}"
        max="${ifDefined(this.type !== 'number' ? undefined : this.max)}"
        step="${ifDefined(this.type !== 'number' ? undefined : this.step)}"
        pattern="${ifDefined(this.pattern)}"
        @change="${this._nativeChange}"
        @input="${this._nativeInput}"
        @focus="${this._nativeFocus}"
        @blur="${this._nativeBlur}"
        @keydown="${this._nativeKeyPress}"
        @keyup="${this._nativeKeyPress}"
        .ariaLabelledBy="${this.getAriaLabelledBy()}"
        .ariaLabel="${this.ariaLabel ? this.ariaLabel : null}"
        class="${classMap(classes)}"
      />
    `;
    }
    renderCharCounter() {
        if (!this.charCounterVisible) {
            return nothing;
        }
        const length = Math.min(String(this.value).length, this.maxlength);
        return html ` <span slot="secondary">${length}/${this.maxlength}</span> `;
    }
    renderLabel() {
        if (this.label || this.secondaryLabel) {
            let optionalLabel = html ``;
            if (this.secondaryLabel && this.secondaryLabel.trim() !== '') {
                optionalLabel = html `<span slot="secondary">${this.secondaryLabel}</span>`;
            }
            return html ` <hds-label id="${this.labelId}">${this.label} ${optionalLabel}</hds-label> `;
        }
        return nothing;
    }
    renderIcon() {
        if (!this.icon) {
            return undefined;
        }
        return html ` <hds-icon name="${this.icon}" category="${this.iconCategory}"></hds-icon>`;
    }
    renderHelperText() {
        if (!this.charCounterVisible && !this.errorTextVisible) {
            return nothing;
        }
        return html `
      <hds-label type="assistive" variant="error">
        ${this.errorText} ${this.renderCharCounter()}
      </hds-label>
    `;
    }
    async _nativeFocus(e) {
        e.stopPropagation();
        e.preventDefault();
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('focus', {
            detail: this,
            bubbles: true,
            composed: true,
        }));
        this.requestUpdate();
    }
    async _nativeBlur(e) {
        e.stopPropagation();
        e.preventDefault();
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('blur', {
            detail: this,
            bubbles: true,
            composed: true,
        }));
        this.requestUpdate();
    }
    async _handleUp(e) {
        if (this.readonly)
            return;
        e.stopPropagation();
        e.preventDefault();
        await this.stepUp(this.step);
    }
    async _handleDown(e) {
        if (this.readonly)
            return;
        e.stopPropagation();
        e.preventDefault();
        await this.stepDown(this.step);
    }
    async _nativeKeyPress(evt) {
        evt.stopPropagation();
        await this.updateComplete;
        this.dispatchEvent(new KeyboardEvent(evt.type, evt));
    }
    async _nativeInput(e) {
        e.stopPropagation();
        e.preventDefault();
        this.value = this.inputElement.value;
        await this.updateComplete;
        this.triggerInputEvent();
    }
    triggerInputEvent() {
        this.dispatchEvent(new CustomEvent('input', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    async _nativeChange(e) {
        e.stopPropagation();
        e.preventDefault();
        this.value = this.inputElement.value;
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('change', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    async _changeByStep(step = 1) {
        let val = this.value;
        if ((!val && parseInt(val, 10) !== 0) || Number.isNaN(val)) {
            val = 0;
        }
        this.value = clamp(parseInt(val, 10) + step, this.min, this.max);
        await this.updateComplete;
        this.triggerInputEvent();
        this.dispatchEvent(new CustomEvent('change', {
            detail: { value: this.value },
            bubbles: true,
            composed: true,
        }));
    }
    _isPasswordVisibilityEnabled() {
        return this.initialType === 'password' && this.passwordVisibility !== 'disabled';
    }
    _renderIconControls() {
        if (this.type === 'number') {
            const iconSize = this.size === 'extra-small' ? '8px' : '16px';
            return html ` <div class="input-controls">
        <div class="input-control up" @click="${this._handleUp}">
          <hds-icon name="chevron-up" size="${iconSize}"></hds-icon>
        </div>
        <div class="input-control down" @click="${this._handleDown}">
          <hds-icon name="chevron-down" size="${iconSize}"></hds-icon>
        </div>
      </div>`;
        }
        if (this._isPasswordVisibilityEnabled()) {
            const iconName = this.passwordVisibility === 'masked' ? 'show' : 'hide';
            return html ` <div class="input-controls">
        <div class="input-control toggle-password" @click="${this.togglePassword}">
          <hds-icon name="${iconName}" size="16px"></hds-icon>
        </div>
      </div>`;
        }
        if (this.type === 'search' && this.value?.length > 0) {
            return html ` <div class="input-controls" @click="${this.clear}">
        <div class="input-control search">
          <hds-icon name="clear" size="16px"></hds-icon>
        </div>
      </div>`;
        }
        return nothing;
    }
};
Input.styles = styles;
Input.idCounter = 0;
Input.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
Input.formAssociated = true;
__decorate([
    property({ type: String })
], Input.prototype, "type", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "id", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "name", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "placeholder", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "label", void 0);
__decorate([
    property({ type: String, attribute: 'secondary-label' })
], Input.prototype, "secondaryLabel", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "size", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "icon", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "pattern", void 0);
__decorate([
    property({ type: String, attribute: 'icon-category' })
], Input.prototype, "iconCategory", void 0);
__decorate([
    property({ type: Boolean })
], Input.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean })
], Input.prototype, "readonly", void 0);
__decorate([
    property({ type: Boolean })
], Input.prototype, "required", void 0);
__decorate([
    property({ type: Boolean })
], Input.prototype, "autofocus", void 0);
__decorate([
    property({ type: Number })
], Input.prototype, "minlength", void 0);
__decorate([
    property({ type: Number })
], Input.prototype, "maxlength", void 0);
__decorate([
    property({ type: Number })
], Input.prototype, "step", void 0);
__decorate([
    property({ type: Boolean, attribute: 'char-counter' })
], Input.prototype, "charCounter", void 0);
__decorate([
    property({ type: Boolean })
], Input.prototype, "error", void 0);
__decorate([
    property({ type: String, attribute: 'error-text' })
], Input.prototype, "errorText", void 0);
__decorate([
    property({ type: String, attribute: 'aria-labelledby' })
], Input.prototype, "ariaLabelledby", void 0);
__decorate([
    property({ type: String, attribute: 'password-visibility' })
], Input.prototype, "passwordVisibility", void 0);
__decorate([
    property({ type: String })
], Input.prototype, "autocomplete", void 0);
__decorate([
    query('input')
], Input.prototype, "inputElement", void 0);
__decorate([
    query('slot[name="left"]')
], Input.prototype, "slotLeft", void 0);
__decorate([
    query('slot[name="right"]')
], Input.prototype, "slotRight", void 0);
__decorate([
    state()
], Input.prototype, "slotLeftHasContent", void 0);
__decorate([
    state()
], Input.prototype, "slotRightHasContent", void 0);
__decorate([
    property({ type: String, reflect: true, attribute: 'value' })
], Input.prototype, "value", null);
__decorate([
    property({ type: Number, attribute: 'min' })
], Input.prototype, "min", null);
__decorate([
    property({ type: Number, attribute: 'max' })
], Input.prototype, "max", null);
Input = Input_1 = __decorate([
    customElement('hds-input')
], Input);
export { Input };
//# sourceMappingURL=hds-input.js.map