import React, { useEffect, useImperativeHandle } from 'react';
import { Textarea, } from '@here/hds-textarea';
// eslint-disable-next-line no-new
new Textarea();
const HDSTextarea = React.forwardRef((props, ref) => {
    const { value, id, name, placeholder, label, secondaryLabel, disabled, readonly, required, autofocus, rows, cols, minlength, maxlength, charCounter, error, errorText, onChange, onKeyDown, onKeyUp, resize, onBlur, onFocus, onInput, className, autocomplete, ...rest } = props;
    const innerRef = React.useRef(null);
    useImperativeHandle(ref, () => innerRef.current);
    const _handleChange = (e) => {
        if (e.target !== innerRef.current)
            return;
        onChange && onChange(e);
    };
    const _handleInput = (e) => {
        if (e.target !== innerRef.current)
            return;
        onInput && onInput(e);
    };
    const _handleBlur = (e) => {
        if (e.target !== innerRef.current)
            return;
        onBlur && onBlur(e);
    };
    const _handleFocus = (e) => {
        if (e.target !== innerRef.current)
            return;
        onFocus && onFocus(e);
    };
    const _handleKeyDown = (e) => {
        if (e.target !== innerRef.current)
            return;
        onKeyDown && onKeyDown(e);
    };
    const _handleKeyUp = (e) => {
        if (e.target !== innerRef.current)
            return;
        onKeyUp && onKeyUp(e);
    };
    useEffect(() => {
        if (onChange && innerRef.current) {
            innerRef.current.addEventListener('change', _handleChange);
        }
        return () => innerRef.current?.removeEventListener('change', _handleChange);
    }, [onChange, innerRef]);
    useEffect(() => {
        if (onKeyDown && innerRef.current) {
            innerRef.current.addEventListener('keydown', _handleKeyDown);
        }
        return () => innerRef.current?.removeEventListener('keydown', _handleKeyDown);
    }, [onKeyDown, innerRef]);
    useEffect(() => {
        if (onKeyUp && innerRef.current) {
            innerRef.current.addEventListener('keyup', _handleKeyUp);
        }
        return () => innerRef.current?.removeEventListener('keyup', _handleKeyUp);
    }, [onKeyUp, innerRef]);
    useEffect(() => {
        if (onInput && innerRef.current) {
            innerRef.current.addEventListener('input', _handleInput);
        }
        return () => innerRef.current?.removeEventListener('input', _handleInput);
    }, [onInput, innerRef]);
    useEffect(() => {
        if (onBlur && innerRef.current) {
            innerRef.current.addEventListener('blur', _handleBlur);
        }
        return () => innerRef.current?.removeEventListener('blur', _handleBlur);
    }, [onBlur, innerRef]);
    useEffect(() => {
        if (onFocus && innerRef.current) {
            innerRef.current.addEventListener('focus', _handleFocus);
        }
        return () => innerRef.current?.removeEventListener('focus', _handleFocus);
    }, [onFocus, innerRef]);
    return (React.createElement("hds-textarea", { value: value, id: id, name: name, placeholder: placeholder, label: label, ...(className && { class: className }), ...(secondaryLabel && { 'secondary-label': secondaryLabel }), ...(disabled && { disabled: true }), ...(readonly && { readonly: true }), ...(autofocus && { autofocus: true }), ...(autocomplete && { autocomplete: autocomplete }), required: required, rows: rows, cols: cols, minlength: minlength, maxlength: maxlength, resize: resize, ...(charCounter && { 'char-counter': charCounter }), ...(error && { error: true }), ...(errorText && { 'error-text': errorText }), ref: innerRef, ...rest }));
});
HDSTextarea.defaultProps = {
    resize: 'none',
};
export default HDSTextarea;
//# sourceMappingURL=HDSTextarea.js.map