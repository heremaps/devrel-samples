import React, { useEffect, useImperativeHandle } from 'react';
import { Input, } from '@here/hds-input';
// eslint-disable-next-line no-new
new Input();
const HDSInput = React.forwardRef((props, ref) => {
    const { value, type, id, name, placeholder, label, secondaryLabel, icon, iconCategory, size, disabled, readonly, required, autofocus, passwordVisibility, minlength, maxlength, min, max, pattern, charCounter, error, errorText, onAction, onChange, onBlur, onFocus, onKeyDown, onKeyUp, onInput, className, ariaLabelledby, ariaLabel, step, autocomplete, ...rest } = props;
    const innerRef = React.useRef(null);
    useImperativeHandle(ref, () => innerRef.current);
    const _handleAction = (e) => {
        if (e.target !== innerRef.current)
            return;
        onAction && onAction(e);
    };
    const _handleChange = (e) => {
        if (e.target !== innerRef.current)
            return;
        onChange && onChange(e);
    };
    const _handleInput = (e) => {
        if (e.target !== innerRef.current)
            return;
        onInput && onInput(e);
    };
    const _handleBlur = (e) => {
        if (e.target !== innerRef.current)
            return;
        onBlur && onBlur(e);
    };
    const _handleFocus = (e) => {
        if (e.target !== innerRef.current)
            return;
        onFocus && onFocus(e);
    };
    const _handleKeyDown = (e) => {
        if (e.target !== innerRef.current)
            return;
        onKeyDown && onKeyDown(e);
    };
    const _handleKeyUp = (e) => {
        if (e.target !== innerRef.current)
            return;
        onKeyUp && onKeyUp(e);
    };
    useEffect(() => {
        if (onAction && innerRef.current) {
            innerRef.current.addEventListener('action', _handleAction);
        }
        return () => innerRef.current?.removeEventListener('action', _handleAction);
    }, [onAction, innerRef]);
    useEffect(() => {
        if (onChange && innerRef.current) {
            innerRef.current.addEventListener('change', _handleChange);
        }
        return () => innerRef.current?.removeEventListener('change', _handleChange);
    }, [onChange, innerRef]);
    useEffect(() => {
        if (onInput && innerRef.current) {
            innerRef.current.addEventListener('input', _handleInput);
        }
        return () => innerRef.current?.removeEventListener('input', _handleInput);
    }, [onInput, innerRef]);
    useEffect(() => {
        if (onBlur && innerRef.current) {
            innerRef.current.addEventListener('blur', _handleBlur);
        }
        return () => innerRef.current?.removeEventListener('blur', _handleBlur);
    }, [onBlur, innerRef]);
    useEffect(() => {
        if (onFocus && innerRef.current) {
            innerRef.current.addEventListener('focus', _handleFocus);
        }
        return () => innerRef.current?.removeEventListener('focus', _handleFocus);
    }, [onFocus, innerRef]);
    useEffect(() => {
        if (onKeyDown && innerRef.current) {
            innerRef.current.addEventListener('keydown', _handleKeyDown);
        }
        return () => innerRef.current?.removeEventListener('keydown', _handleKeyDown);
    }, [onKeyDown, innerRef]);
    useEffect(() => {
        if (onKeyUp && innerRef.current) {
            innerRef.current.addEventListener('keyup', _handleKeyUp);
        }
        return () => innerRef.current?.removeEventListener('keyup', _handleKeyUp);
    }, [onKeyUp, innerRef]);
    return (React.createElement("hds-input", { value: value, type: type, id: id, name: name, placeholder: placeholder, label: label, ...(secondaryLabel && { 'secondary-label': secondaryLabel }), ...(passwordVisibility && { 'password-visibility': passwordVisibility }), icon: icon, ...(iconCategory && { 'icon-category': iconCategory }), size: size, ...(disabled && { disabled: true }), ...(readonly && { readonly: true }), ...(required && { required: true }), ...(autofocus && { autofocus: true }), ...(className && { class: className }), minlength: minlength, maxlength: maxlength, min: min, max: max, step: step, pattern: pattern, ...(charCounter && { 'char-counter': charCounter }), ...(error && { error: true }), ...(errorText && { 'error-text': errorText }), ...(ariaLabelledby && { 'aria-labelledby': ariaLabelledby }), ...(ariaLabel && { 'aria-label': ariaLabel }), ...(autocomplete && { autocomplete: autocomplete }), ref: innerRef, ...rest }));
});
HDSInput.defaultProps = {
    type: 'text',
    id: '',
    name: undefined,
    placeholder: undefined,
    label: undefined,
    secondaryLabel: undefined,
    size: 'medium',
    icon: undefined,
    pattern: undefined,
    iconCategory: 'core-ui',
    disabled: false,
    readonly: false,
    required: false,
    autofocus: false,
    minlength: -1,
    maxlength: -1,
    step: 1,
    charCounter: false,
    error: false,
    errorText: undefined,
    ariaLabelledby: undefined,
    ariaLabel: '',
    passwordVisibility: 'masked',
    autocomplete: '',
};
export default HDSInput;
//# sourceMappingURL=HDSInput.js.map