var Notification_1;
import { __decorate } from "tslib";
/* eslint-disable no-param-reassign */
import { customElement, isSlotEmpty } from '@here/hds-base';
import { html, LitElement, nothing } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styles } from './hds-notification.css.js';
/**
 *
 * @slot default - Main content for the notification
 * @slot action - Custom action(s)
 *
 * @event {CustomEvent<{open: boolean}>} change Fired when the notification changes the state: open / close `NotificationChangePayload`
 * @event {CustomEvent<{action: string}>} action Fired when the action has been clicked
 */
let Notification = Notification_1 = class Notification extends LitElement {
    constructor() {
        super(...arguments);
        this.open = false;
        this.variant = 'solid';
        this.status = 'default';
        this.headline = '';
        this.size = 'medium';
        this.timeout = 0;
        this.hideIcon = false;
        this.keepNode = false;
        this.inline = false;
        this.hideClose = false;
        this.closeAriaLabel = 'Close';
        this.isDefaultSlotNotEmpty = false;
        this.isActionSlotNotEmpty = false;
        // eslint-disable-next-line no-undef
        this._timeoutId = null;
    }
    get type() {
        return this.inline ? 'inline' : 'toast';
    }
    disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback();
        this.clearTimeout();
    }
    close() {
        this.open = false;
        this.clearTimeout();
        if (!this.keepNode) {
            this.remove();
        }
    }
    updated(changedProperties) {
        if (changedProperties.has('open') && changedProperties.get('open') !== undefined) {
            this.dispatchEvent(new CustomEvent('change', {
                detail: {
                    open: this.open,
                },
            }));
        }
        if (this.open && this._timeoutId === null && this.timeout > 0) {
            this._timeoutId = setTimeout(() => {
                this.close();
            }, this.timeout * 1000);
        }
    }
    renderClose() {
        if (this.hideClose)
            return nothing;
        return html `<hds-button
      role="button"
      class="close"
      icon="cross"
      variant="${this.variant === 'solid' ? 'on-color-secondary' : 'subtle'}"
      @click="${this.close}"
      size="extra-small"
      aria-label="${this.closeAriaLabel}"
    ></hds-button>`;
    }
    async onActionSlotChange(e) {
        this.isActionSlotNotEmpty = !isSlotEmpty(e.target);
        this.querySelectorAll('hds-button[slot=action]').forEach((button) => {
            if (this.type === 'toast') {
                if (!button.hasAttribute('data-hds-variant-original')) {
                    button.setAttribute('data-hds-variant-original', button.variant);
                }
                const isPrimary = button.getAttribute('data-hds-variant-original') === 'primary';
                if (isPrimary && this.status === 'default' && this.variant === 'solid') {
                    button.variant = 'primary';
                }
                else if (isPrimary && this.status === 'positive' && this.variant === 'solid') {
                    button.variant = 'success';
                }
                else if (isPrimary && this.status === 'warning' && this.variant === 'solid') {
                    button.variant = 'warning';
                }
                else if (isPrimary && this.status === 'error' && this.variant === 'solid') {
                    button.variant = 'danger';
                }
                else if (isPrimary && this.status === 'inverse' && this.variant === 'solid') {
                    button.variant = 'primary';
                }
                else if (isPrimary && this.status === 'default' && this.variant === 'subtle') {
                    button.variant = 'primary';
                }
                else if (isPrimary && this.status === 'positive' && this.variant === 'subtle') {
                    button.variant = 'success-quiet';
                }
                else if (isPrimary && this.status === 'warning' && this.variant === 'subtle') {
                    button.variant = 'warning-quiet';
                }
                else if (isPrimary && this.status === 'error' && this.variant === 'subtle') {
                    button.variant = 'danger-quiet';
                }
                else if (isPrimary && this.status === 'inverse' && this.variant === 'subtle') {
                    button.variant = 'primary';
                }
                else {
                    button.variant = 'secondary';
                }
                button.size = this.size;
                button.setAttribute('width', '100%');
            }
            else if (this.type === 'inline' && this.variant === 'solid') {
                button.variant = 'on-color-secondary';
                button.size = 'extra-small';
            }
            else if (this.type === 'inline' && this.variant === 'subtle') {
                button.variant = 'link';
                button.size = 'large';
            }
        });
    }
    async onDefaultSlotChange(e) {
        this.isDefaultSlotNotEmpty = !isSlotEmpty(e.target);
    }
    async onActionClick(e) {
        e.stopPropagation();
        const action = e.target.getAttribute('data-action') || 'custom';
        const detail = { action };
        await this.updateComplete;
        this.dispatchEvent(new CustomEvent('action', {
            detail,
            bubbles: true,
        }));
    }
    renderActions() {
        const classes = {
            actions: true,
            [`actions-${this.type}`]: true,
            [`${this.isActionSlotNotEmpty ? 'has' : 'no'}-actions`]: true,
        };
        return html `<div class="${classMap(classes)}">
      <slot
        name="action"
        @slotchange="${this.onActionSlotChange}"
        @click="${this.onActionClick}"
      ></slot>
    </div>`;
    }
    renderIcon() {
        if (this.hideIcon)
            return nothing;
        return html `<hds-icon
      class="icon"
      name="${Notification_1.ICON_NAME_BY_STATUS[this.status]}"
      size="${this.size === 'medium' ? '24px' : '16px'}"
      category="core-ui"
      icon-style="solid"
    ></hds-icon>`;
    }
    render() {
        const classes = {
            open: this.open,
            '-hds-notification-wrapper': true,
            [`hds-notification-variant-${this.variant}`]: true,
            [`hds-notification-status-${this.status}`]: true,
            [`hds-notification-type-${this.type}`]: true,
            [`hds-notification-size-${this.size}`]: true,
            [`${this.isDefaultSlotNotEmpty ? 'has' : 'no'}-content`]: true,
            [`${this.hideClose ? 'no' : 'has'}-close`]: true,
            [`${this.isActionSlotNotEmpty ? 'has' : 'no'}-actions`]: true,
        };
        return html `
      <div
        class="${classMap(classes)}"
        role="alert"
        aria-live="polite"
        aria-atomic="true">
        <div class="headline">
          ${this.renderIcon()}
          <div class="headline-text">
            ${this.headline}
          </div>
          ${this.type === 'inline' ? this.renderActions() : nothing}
          ${this.renderClose()}
        </div>
        <div class="content">
          <slot @slotchange="${this.onDefaultSlotChange}"></slot>
          ${this.type === 'toast' ? this.renderActions() : nothing}
        </div>
      </div>
      </div>`;
    }
    clearTimeout() {
        if (this._timeoutId !== null) {
            clearTimeout(this._timeoutId);
        }
    }
};
Notification.styles = styles;
Notification.ICON_NAME_BY_STATUS = {
    default: 'information',
    positive: 'confirm',
    warning: 'attention',
    error: 'alert',
    inverse: 'information',
};
__decorate([
    property({ type: Boolean, reflect: true })
], Notification.prototype, "open", void 0);
__decorate([
    property({ type: String })
], Notification.prototype, "variant", void 0);
__decorate([
    property({ type: String })
], Notification.prototype, "status", void 0);
__decorate([
    property({ type: String, reflect: true })
], Notification.prototype, "headline", void 0);
__decorate([
    property({ type: String })
], Notification.prototype, "size", void 0);
__decorate([
    property({ type: Number })
], Notification.prototype, "timeout", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-icon' })
], Notification.prototype, "hideIcon", void 0);
__decorate([
    property({ type: Boolean, attribute: 'keep-node' })
], Notification.prototype, "keepNode", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], Notification.prototype, "inline", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'hide-close' })
], Notification.prototype, "hideClose", void 0);
__decorate([
    property({ type: String, attribute: 'close-aria-label' })
], Notification.prototype, "closeAriaLabel", void 0);
__decorate([
    state()
], Notification.prototype, "isDefaultSlotNotEmpty", void 0);
__decorate([
    state()
], Notification.prototype, "isActionSlotNotEmpty", void 0);
Notification = Notification_1 = __decorate([
    customElement('hds-notification')
], Notification);
export { Notification };
//# sourceMappingURL=hds-notification.js.map